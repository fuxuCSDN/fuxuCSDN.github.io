<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Cat</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://9cat.top/"/>
  <updated>2018-07-01T09:49:14.844Z</updated>
  <id>http://9cat.top/</id>
  
  <author>
    <name>water</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.1.3Winsock网络编程知识（下）</title>
    <link href="http://9cat.top/2018/07/01/2-1-3Winsock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://9cat.top/2018/07/01/2-1-3Winsock网络编程知识（下）/</id>
    <published>2018-07-01T07:28:58.000Z</published>
    <updated>2018-07-01T09:49:14.844Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="！上接Winsock网络编程知识（上）！"><a href="#！上接Winsock网络编程知识（上）！" class="headerlink" title="！上接Winsock网络编程知识（上）！"></a>！上接Winsock网络编程知识（上）！</h1><p>sockaddr结构体是为了保持各个特定协议之间的兼容性而设计的。为bind()函数指定的地址和端口时，向sockaddr_in结构体填充相应的内容，而调用函数时应该使用sockaddr结构体。<br>在sockaddr_in结构体中，还有一个结构体in_addr，该结构体在winsock2.h中的定义如下:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123; <span class="title">u_char</span> <span class="title">s_bl</span>,<span class="title">s_b2</span>,<span class="title">s_b3</span>,<span class="title">s_b4</span>;</span> &#125;      S_un_b;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123; <span class="title">u_short</span> <span class="title">s_wl</span>,<span class="title">s_w2</span>;</span> &#125;     S_un_w;</span><br><span class="line"> u_long     S_addr;</span><br><span class="line"> &#125;S_un;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>该结构体是一个共用体S_un，包含2个结构体变量和1u_long类型变量。一般使用的IP地址的数据类型是使用<code>点分十进制</code>表示的,而in_addr结构体中却没有提供用来保存点分十进制表示IP地址的数据类型，只是需要使用转换函数，把<code>点分十进制</code>表示的IP地址转换成in_addr结构体可以接受的类型。这里使用的转换函数是inet_addr(),该函数的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>  FAR *cp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该函数是将点分十进制表示的IP地址转换成<code>unsigned long</code>类型的数值。该函数的参数cp是指向点分十进制IP地址的<code>字符指针</code>。同时该函数也是一个<code>逆函数</code>，是将unsigned long型的数值型IP地址转换成点分十进制的IP地址，该函数的定义如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> FAR * inet_ntoa(<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span> <span class="keyword">in</span>);</span><br></pre></td></tr></table></figure></p><p>sockaddr_in结构体中的sin_port表示端口，这个端口需要使用大尾方式字节序存储（也称大端和小端，是两种不同的存储方式。）在intel X86架构下，数值存储方式默认W为小尾方式字节序，而TCP/IP的数值的存储方式都是大尾方式的字节序。为了实现方便的转换，winsock2.h中提供为了方便的函数，即htons()和htonl()两个函数，并且提供了他们的逆函数ntohs()和ntohl()。<br>htons()和htonl()函数的定义分别如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_short htons(<span class="name">u_short</span> hostshort)<span class="comment">;</span></span><br><span class="line">u_long  htonl(<span class="name">u_long</span> hostlong)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>ntohs()和ntohl()函数的定义分别如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u_short ntohs(<span class="name">u_short</span> netshort)<span class="comment">;</span></span><br><span class="line">u_long ntohl(<span class="name">u_long</span> netlong)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>这4个函数中，前两个函数是将<code>主机字节序</code>转换成<code>网络字节序</code>，后两个是将<code>网络字节序</code>转换成<code>主机字节序</code>。在有些架构系统下，主机字节序和网络字节序是相同的，那么转换函数不进行任何转换，但是为了代码的移植性，还是会进行转换函数的调用。<br>具体的bind()函数的使用方法如下：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">SOCKET sListen = socket(PF_INEF, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">//对sockaddr_in结构体填充地址、端口等信息</span></span><br><span class="line">struct sockaddr_in ServerAddr;</span><br><span class="line">ServerAddr.sin_family = AF_INEF;</span><br><span class="line">ServerAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">"10.10.30.16"</span>);</span><br><span class="line">ServerAddr.sin_port = htons(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定套接字与地址信息</span></span><br><span class="line">bind(sLisent, (SOCKADDR *)&amp;ServerAddr, sizeof(serverAddr));</span><br></pre></td></tr></table></figure></p><p>PS:对于服务器的地址可以指定为INADDR_ANY宏，表示“任意地址”或者“所有地址”。当客户端发起连接时。服务器操作系统接收到客户端的连接，根据网络的配置情况会自动选择一个IP地址和客户端进行通信。<br>当套接字与地址端口信息绑定后，就需要让端口进行监听，当端口进行监听状态以后就可以接受其他主机的连接了。监听端口和接受连接请求的函数分别为listen()和accept()。<br>监听端口的函数定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(SOCKET s, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该函数有两个参数，第1个参数s是指定要监听的套接字描述符，第2个参数是backlog是允许进入请求连接队列的个数，backlog的最大值由系统指定，在winsock2.h中，其最大值由SOMAXCONN表示，该值的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOMAXCONN     0x7fffffff</span></span><br></pre></td></tr></table></figure></p><p>接受连接请求的函数定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">accept</span>(<span class="params">SOCKET s,<span class="keyword">struct</span> sockaddr FAR *addr, <span class="keyword">int</span> FAR *addrlen</span>)</span>;</span><br></pre></td></tr></table></figure></p><p>该函数从<code>连接请求队列</code>中获取<code>连接信息</code>，创建新的套接字描述符，获取客户端地址。新创建的套接字用于和客户端进行通信。该函数有3个参数，第1个参数s是<code>处于监听套接字描述符</code>，第2个参数addr是一个<code>指向sockaddr结构体的指针</code>，用来返回客户端的地址信息，第3个参数addrlen是一个<code>指向int型的指针变量</code>，用来传入sockaddr结构体的大小。<br>上面介绍的是面向连接的服务器端的函数，完成了一系列服务器应有的基本动作，如下：<br>    首先，bind()函数将套接字描述符与地址信息进行绑定；<br>    其次，listen()函数将套接字描述符置于监听状态；<br>    最后，accept()函数获取连接队列中的连接信息，创建新的套接字描述符，以便与客户端通信。<br>面向连接的客户端只需要完成与服务器的连接这样一个动作就可以实现和服务器的通信了。创建套接字描述符后，使用connect()函数就可以完成与服务器的连接。<br>connet函数的定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connet</span>(<span class="params">SOCKES s, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr FAR *name,<span class="keyword">int</span> namelen</span>)</span>;</span><br></pre></td></tr></table></figure></p><p>该函数的作用是将套接字进行连接。该函数有3个参数，第1个参数表示创建好的<code>套接字描述符</code>，第2个参数name是指向sockaddr结构体的<code>指针</code>，sockaddr结构体中保存了服务器的IP和端口号，第3个参数namelen是指定sockaddr<code>结构体的长度</code>。<br>当客户端使用connect()函数与服务器连接后，客户端和服务器就可以通信了。通信时主要就是信息的发送和接收。这里介绍的函数有两个，分别是send()和recv()。<br>发送函数send()的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET s, <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf, <span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该函数有4个参数，第1个<code>参数s</code>是accept()函数返回的套接字描述符，第二个<code>参数buf</code>是发送消息的缓冲区，第3个<code>参数len</code>是缓冲区的长度，第4个<code>参数flags</code>通常赋值为0值。<br>接收函数recv()的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(SOCKET s,<span class="keyword">char</span> FAR *buf,<span class="keyword">int</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p><p>该函数有4个参数，该函数的使用方法和send()函数的使用方法相同。这里不再介绍。</p><h2 id="4-非面向连接协议的函数"><a href="#4-非面向连接协议的函数" class="headerlink" title="4.非面向连接协议的函数"></a>4.非面向连接协议的函数</h2><p>在面向连接的TCP协议中，服务器端将套接字描述符与地址进行绑定后，需要将端口进行<code>监听</code>，等待接受客户端的连接请求，而在客户端则需要连接服务器，完成这些步骤就可以保证面向连接的TCP协议的可靠传输，在调用connect()函数的过程中也完成了TCP的“三次握手”的过程。非面向连接的UDP协议在开发上基本与面向连接TCP相同。在非面向连接的UDP协议开发中服务器端不需要对端口进行监听，也就不需要等待接受客户端的连接请求，而客户端也不需要完成与服务器的连接。中间的“三次握手”过程也就省略了，这样UDP协议现对于TCP协议来讲就显得不可靠，但是效率会更高。（游戏方面一般采用DUP协议）<br>在非面向连接协议开发中，服务器端不再调用listen()、accept()函数，客户端不再需要调用connect()函数。而服务器和客户端的通信换为sendto()和recvfrom()函数即可。<br>sendto函数的定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr FAR *to,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> tolen</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure></p><p>该函数是用来在UDP协议通信双方进行发送数据的函数，该函数有6个参数，第1个参数s是套接字描述符，第2个参数buf是要发送数据的缓冲区，第3个参数len是指定第2个参数的长度，第4个参数通常赋0值，第5个参数to是一个指向sockaddr结构体的指针，这里给出接收信息的地址信息，第6个参数tolen是指定第5个参数的长度。<br>recvfrom()函数的定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  SOCKET s,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr FAR *<span class="keyword">from</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> FAR *fromlen</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure></p><p>该函数是用来在UDP协议通信双方进行接收数据的函数。该函数的用法与sendto()相同，这里不再介绍。<br>PS：在缓冲区后设置数据的长度是为了防止缓冲区溢出！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络编程" scheme="http://9cat.top/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Winsock" scheme="http://9cat.top/tags/Winsock/"/>
    
  </entry>
  
  <entry>
    <title>2.1.3Winsock网络编程知识（上）</title>
    <link href="http://9cat.top/2018/07/01/2-1-3Winsock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://9cat.top/2018/07/01/2-1-3Winsock网络编程知识（上）/</id>
    <published>2018-07-01T05:39:48.000Z</published>
    <updated>2018-07-01T07:25:57.738Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Winsock的初始化与释放"><a href="#1-Winsock的初始化与释放" class="headerlink" title="1.Winsock的初始化与释放"></a>1.Winsock的初始化与释放</h2><p>在使用winsock相关函数时需要对Winsock库进行初始化，而在使用完后需要对Winsock库进行释放。</p><h3 id="Winsock库的初始化函数的定义如下："><a href="#Winsock库的初始化函数的定义如下：" class="headerlink" title="Winsock库的初始化函数的定义如下："></a>Winsock库的初始化函数的定义如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSAStartup</span><span class="params">(WORD wVersionRequested, LPWSADATA lpWSAData)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的第1个参数wVersionRequested是需要初始化的Winsock库的版本号，Winsock库有多个版本号，目前常用的版本是2.2.第二个参数<code>lpWSAData</code>是一个指向WSADATA的指针。该函数的返回值为0，说明该函数调用成功。如果调用失败，则返回其他值。在程序的开始处调用该初始化函数，在程序中就可以使用Winsock相关的所有API函数。</p><h3 id="Winsock库的释放函数的定义"><a href="#Winsock库的释放函数的定义" class="headerlink" title="Winsock库的释放函数的定义"></a>Winsock库的释放函数的定义</h3><p>int WSACleanup(void);<br>该函数没有参数，在程序的结束处直接调用该函数，即可释放Winsock库。</p><h2 id="2-套接字的创建与关闭"><a href="#2-套接字的创建与关闭" class="headerlink" title="2.套接字的创建与关闭"></a>2.套接字的创建与关闭</h2><p>套接字用于根据指定的<code>协议类型</code>来分配一个<code>套接字描述符</code>。该描述符主要用在客户端和服务器端进行通信，当套接字使用完毕时应该关闭套接字以释放资源。创建套接字与关闭套接字的函数为socket()和closesocket()。</p><h3 id="创建套接字的函数定义如下："><a href="#创建套接字的函数定义如下：" class="headerlink" title="创建套接字的函数定义如下："></a>创建套接字的函数定义如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>socket()函数共有3个参数，第1个参数af用来指定地址族，在Windows下可以使用的参数有很多个，但是真正可以使用的只有两个，分别说AF_INET和PF_INET。这两个宏在Winsock2.h下的定义相同，分别如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET2<span class="comment">/* internetwork:UDP, TCP, etc. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Protocol families,same as address families for now</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INEFAF_INEF</span></span><br></pre></td></tr></table></figure></p><p>以上两个定义都摘自Winsock2.h头文件。从定义来看，PF_INEF和AF_INEF是相同的。看PF_INEF宏定义上面的注释，AF表示地址族（Address Family）,而PF表示协议族（Protocol Family）。对于Windows来说，<code>两者相同</code>；对于Unix/Linux来说，两者是<code>不同的</code>。一般情况下，调用socket()函数时应使用<code>PF_INEF</code>，而在设置地址时使用<code>AF_INEF</code>。<br>sock()函数的第2个参数type是指定新套接字描述符的类型。这里可以使用的值通常有3个，分别是SOCK_STREAM、SOCK_DGRAM和SOCK_RAW，分别表示流套接字、数据包套接字和原始协议接口。<br>socket()函数的第3个参数Protocol用来指定程序所使用的通信协议，这里可以选择使用IPPROTO_TCP、IPPROTO_UDP、IPPROTO_ICMP等协议，这个参数的值是根据<code>第2个参数</code>的值进行选择。第2个参数如果使用<code>SOCK_STREAM</code>，那么第3个参数应该使用<code>IPPROTO_TCP</code>；如果第2个参数使用SOCK_DGRAM，那么第3个参数应该使用IPPROTO_UDP。也就是说，如果第2个参数是SOCK_STREAM或SOCK_DGRAM，那么第3个参数可以默认为0.如果第2个参数指定的是SOCK_RAW，那么第3个参数必须指定，而不能使用0值。<br>socket()函数调用成功返回值为一个新的套接字描述符，如果调用失败，则返回INVALID_SOCKET。调用失败后，想要知道原因，那么紧接着调用WSAGetLastError()函数得到错误码。<br>PS：所有的Winsock函数出错后都可以调用WSAGetLastError()得到错误码。</p><h3 id="关闭套接字的函数定义如下："><a href="#关闭套接字的函数定义如下：" class="headerlink" title="关闭套接字的函数定义如下："></a>关闭套接字的函数定义如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket</span><span class="params">(SOCKET s)</span></span>;</span><br></pre></td></tr></table></figure><p>closesocket()函数是socket()函数创建的套接字描述符。<br>PS：对于WSAStartup()/WSACleanup()和socket()/closesocket()这样的函数，最好保持成对出现。也就是说，在写完一个函数时，立刻写出另外一个函数的调用，以免忘记资源的释放。</p><h2 id="3-面向连接协议的函数"><a href="#3-面向连接协议的函数" class="headerlink" title="3.面向连接协议的函数"></a>3.面向连接协议的函数</h2><p>前面的部分提到了面向连接协议与非面向连接协议所用到的函数是不相同的。这里来介绍面向连接的函数：bind()、listen()、accept()、send()和recv()。这些函数是常用的<code>面向连接的函数</code>，只是一个基础。Winsock库的函数非常多，这里只是寥寥几个而已，下面介绍函数的使用方法。<br>通过socket()函数可以直接创建一个新的套接字描述符，但是它只是一个描述符，为网络的一些资源做准备。要想真正在网络上进行通信，需要<code>本地的地址</code>与<code>本地的端口号信息</code>。当然，本地的地址与端口号信息需要和套接字描述符进行关联，进行绑定。在Winsock函数中，使用bind()函数完成套接字与地址端口信息的绑定。bind()函数的定义如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span>(<span class="params">SOCKET s, <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr FAR *name, <span class="keyword">int</span> namelen</span>)</span>;</span><br></pre></td></tr></table></figure></p><p>该函数有3个参数，第1个参数s是新创建的套接字描述符，也就是用socket()函数创建的描述符，第2个参数name是一个sockaddr的结构体，提供套接字一个地址和端口信息，第3个参数namelen是sockaddr结构体的大小。<br>其中第二个参数sockaddr结构体的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">u_short sa_family；   <span class="comment">/* address family */</span></span><br><span class="line"><span class="keyword">char</span>    sa_data[<span class="number">14</span>];  <span class="comment">/* up to 14 bytes of direct address */</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure></p><p>该结构体共有16个字节，在该结构体之前所使用的协议为sockadd_in，该结构体的定义如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockadd_in</span>&#123;</span></span><br><span class="line"><span class="keyword">short</span> sin_family;</span><br><span class="line">u_short sin_port;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">in_add</span> <span class="title">sin_addr</span>;</span></span><br><span class="line"><span class="keyword">char</span>sin_size[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>！未完待续！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络编程" scheme="http://9cat.top/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Winsock" scheme="http://9cat.top/tags/Winsock/"/>
    
  </entry>
  
  <entry>
    <title>2.1.2面向与非面连接协议所使用的函数</title>
    <link href="http://9cat.top/2018/07/01/2-1-2%E9%9D%A2%E5%90%91%E4%B8%8E%E9%9D%9E%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://9cat.top/2018/07/01/2-1-2面向与非面连接协议所使用的函数/</id>
    <published>2018-07-01T05:14:08.000Z</published>
    <updated>2018-07-01T05:34:25.436Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-面向连接的协议"><a href="#1-面向连接的协议" class="headerlink" title="1.面向连接的协议"></a>1.面向连接的协议</h2><p>在面向连接的协议中，两台计算机之间在进行数据收发前，必须先在两者之间建立一个<code>通信通道</code>，以确保两台计算机之间存在一条路径可以相互沟通。在数据传输完毕之后，切断这条通信通道。该种方式相当于打电话。<br>面向连接的协议使用的是TCP协议，服务器与客户端建立通信信道所需要的基本Winsock函数如下：</p><h3 id="服务器端函数："><a href="#服务器端函数：" class="headerlink" title="服务器端函数："></a>服务器端函数：</h3><p>socket()-&gt;bind-&gt;listen()-&gt;accept()-&gt;send()/recv()-&gt;closesocket()</p><h3 id="客户端函数："><a href="#客户端函数：" class="headerlink" title="客户端函数："></a>客户端函数：</h3><p>socket()-&gt;connet()-&gt;send()/recv()-&gt;closesocket()</p><h2 id="2-非面向连接的协议"><a href="#2-非面向连接的协议" class="headerlink" title="2.非面向连接的协议"></a>2.非面向连接的协议</h2><p>在非面向连接的协议中，发送端只要直接将要发送的数据传出即可，不需要理会接送方是否能够接收到数据。而接受端在接受数据时，也不会响应消息通知发送给发送端。该种方式相当于写信，将写好的信放到信箱中，但是却不能保证收信人真的能够收到这封信。<br>非面向连接使用的是UDP协议，服务器与客户端通信所需要的基本Winsock函数如下：</p><h3 id="服务器端函数：-1"><a href="#服务器端函数：-1" class="headerlink" title="服务器端函数："></a>服务器端函数：</h3><p>socket()-&gt;bind-&gt;sendto()/recvfrom()-&gt;closesocket()</p><h3 id="客户端函数：-1"><a href="#客户端函数：-1" class="headerlink" title="客户端函数："></a>客户端函数：</h3><p>socket()-&gt;sendto()/recvfrom()-&gt;closesocket()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络编程" scheme="http://9cat.top/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数" scheme="http://9cat.top/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2.1.1网络基础知识</title>
    <link href="http://9cat.top/2018/07/01/2.1.1%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://9cat.top/2018/07/01/2.1.1网络基础知识/</id>
    <published>2018-07-01T03:55:42.000Z</published>
    <updated>2018-07-01T05:38:05.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>各种计算机之间通过互联网进行通信主要依靠TCP/IP协议。该协议分为4层，由上到下分别为<code>应用层、传输层、网际层和链路层</code>。<br>TCP/IP协议总是下层为上层协议服务，下层协议的细节对上层协议来说是透明的。TCP/IP协议在每层协议中都定义了非常多的不同的协议，<br>比如网际层的ICMP协议、IGMP协议，传输层的TCP协议、UDP协议等。<br>在众多协议中，最具有代表性的是TCP/IP协议。</p><p>IP协议是“Internet Protocol”的简称，它是计算机网络相互连接进行通信而设计的协议。在IP协议中最重要的就是<code>IP地址</code>，IP地址是用来在网络上唯一标识一台计算机主机的地址。<br>互联网中没有两个<code>机器</code>有相同的IP地址，因此它是用来标识一台网络主机的。所有的IP地址都是32位长，它用点分十进制表示，比如“10.10.30.16”。<br>IP地址指定的不是主机，而是<code>网络接口设备</code>。因此，一台主机有两个网络接口，那么就会有两个IP地址。通常情况下，对于一台普通主机只有一个网络接口设备，也就只有一个IP地址。比如：个人使用的PC通常只有一个IP地址；<br>而对于服务器来说，则会有多个网络接口设备，每个网络接口设备都有一个IP地址，比如WEB服务器可能就会有多个IP地址。</p><p>IP地址被分为5类，分别是A类、B类、C类、D类和E类。各类IP地址范围如下所示。<br><img src="IP.png" alt=""></p><p>传输层有两大协议，分别是TCP协议和UDP协议。<br>TCP协议是“Transmission Control Protocol”的简称，其意思是传输层控制协议。TCP协议是一种面向连接的、可靠的通信协议。TCP协议是IP协议的上层协议，IP协议服务于TCP协议。<br>UDP协议是“User Datagram Protocol”的简称，其意思为用户包协议。UDP协议是一种<code>无连接</code>的传输层协议，提供面向事务的简单<code>不可靠</code>信息传送服务。<br>传输层是为应用层提供服务的，应用层的协议一部分是基于TCP协议的，比如FTP、HTTP。而一部分是基于UDP的，比如DNS协议。IP层提供了<code>IP地址</code>用来标识网络主机，而传输层提供<code>端口</code>来标识主机中的进程。确定了IP地址和端口号，就确定了网络上的主机以主机上通信的进程。<br>传输层提供了标识通信进程的端口号。按照协议划分，端口号分为TCP端口和UDP端口，TCP端口和UDP端口各有65536个。对于应用程序而言，一般使用大于<code>1024</code>的端口号，因为小于1024的端口属于保留端口。Internet上的很多服务都是用小于1024的端口号。为避免冲突，程序员自己编写的应用程序不要使用小于1024的端口号。同一协议的端口不能冲突，比如Web服务器占用主机TCP协议的80端口，那么另外的程序就不可以再使用TCP协议的80端口。<br>常见的端口号如下图所示。<br><img src="port_number.png" alt=""><br>除了小于1024端口号外，还有一些比较有名的端口号，比如MY SQL Server的端口号是1433，Windows的远程桌面端口号是3389等。程序员在编写自己的网络应用程序时，要避免与这些常用端口冲突。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="网络编程" scheme="http://9cat.top/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络编程" scheme="http://9cat.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>大O记法</title>
    <link href="http://9cat.top/2018/07/01/%E5%A4%A7O%E8%AE%B0%E6%B3%95/"/>
    <id>http://9cat.top/2018/07/01/大O记法/</id>
    <published>2018-07-01T03:41:42.000Z</published>
    <updated>2018-07-01T03:42:28.788Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a>大O记法</h1><h3 id="C-的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。"><a href="#C-的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。" class="headerlink" title="C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。"></a>C++的<strong>大O记法</strong>是算法的时间复杂度表达公式。简单的说<code>大O记法</code>可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。</h3><h3 id="O-1-算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。"><a href="#O-1-算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。" class="headerlink" title="O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。"></a><code>O(1)</code> 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。</h3><h3 id="“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。"><a href="#“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。" class="headerlink" title="“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。"></a>“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。</h3><h3 id="考虑一个数组，按照数组下标的到一个元素的引用"><a href="#考虑一个数组，按照数组下标的到一个元素的引用" class="headerlink" title="考虑一个数组，按照数组下标的到一个元素的引用"></a>考虑一个数组，按照数组下标的到一个元素的引用</h3><h3 id="int-arr-100"><a href="#int-arr-100" class="headerlink" title="int arr[100];"></a>int arr[100];</h3><h3 id="int-x-arr-88-这个算法就是O-1-的"><a href="#int-x-arr-88-这个算法就是O-1-的" class="headerlink" title="int x = arr[88]; //这个算法就是O(1)的"></a>int x = arr[88]; //这个算法就是<code>O(1)</code>的</h3><h3 id="O-1-是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。"><a href="#O-1-是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。" class="headerlink" title="O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。"></a>O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。</h3><h3 id="O-N-算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例"><a href="#O-N-算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例" class="headerlink" title="O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例"></a><code>O(N)</code> 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例</h3><h3 id="考虑一个list链表"><a href="#考虑一个list链表" class="headerlink" title="考虑一个list链表"></a>考虑一个list链表</h3><h3 id="list-remove-88-把第88个元素删除。这个算法就是O-N-的"><a href="#list-remove-88-把第88个元素删除。这个算法就是O-N-的" class="headerlink" title="list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的"></a>list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的</h3><h3 id="O-N-是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。"><a href="#O-N-是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。" class="headerlink" title="O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。"></a>O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。</h3><h3 id="O-logN-算法只花费logN个单位时间长度的时间。"><a href="#O-logN-算法只花费logN个单位时间长度的时间。" class="headerlink" title="O(logN) 算法只花费logN个单位时间长度的时间。"></a>O(logN) 算法只花费logN个单位时间长度的时间。</h3><h3 id="logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536-16-因为2-16-65536"><a href="#logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536-16-因为2-16-65536" class="headerlink" title="logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)"></a>logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)</h3><h3 id="对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。"><a href="#对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。" class="headerlink" title="对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。"></a>对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。</h3><h3 id="考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O-logN-的。"><a href="#考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O-logN-的。" class="headerlink" title="考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。"></a>考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。</h3><h3 id="O-log-一个亿-约等于19个单位时间的时长。"><a href="#O-log-一个亿-约等于19个单位时间的时长。" class="headerlink" title="O(log(一个亿))约等于19个单位时间的时长。"></a>O(log(一个亿))约等于19个单位时间的时长。</h3><h3 id="O-logN-也不一定是以2为底的，也可能是以3为底的，这都无所谓。"><a href="#O-logN-也不一定是以2为底的，也可能是以3为底的，这都无所谓。" class="headerlink" title="O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。"></a>O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。</h3><h3 id="算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。"><a href="#算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。" class="headerlink" title="算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。"></a>算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。</h3><h3 id="但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。"><a href="#但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。" class="headerlink" title="但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。"></a>但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="算法和数据结构" scheme="http://9cat.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP调试工具</title>
    <link href="http://9cat.top/2018/06/24/IP/"/>
    <id>http://9cat.top/2018/06/24/IP/</id>
    <published>2018-06-24T11:58:55.000Z</published>
    <updated>2018-06-24T13:34:06.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dos下的一些命令"><a href="#dos下的一些命令" class="headerlink" title="dos下的一些命令"></a>dos下的一些命令</h1><p>netstat -s -p tcp/udp/icmp/ip  </p><p>ping -l 65500 -t 192.168.1.1  #死亡之ping  </p><p>for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.1.%i  #批处理ping  </p><p>for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.2.%i  </p><p>nbtstat -a 192.168.1.106   探测主机名  </p><p>add portopening protocol =all port=135 name=关闭135端口 mode=enable SCOP=Subnet  </p><p>netsh advfirewall firewall  </p><p>add portopening protocol =tcp port=55555 name重要服务 mode=enable  </p><p>delete portopening protocol =tcp port=55555 interface=重要服务  </p><p>delete portopening TCP 135</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim</title>
    <link href="http://9cat.top/2018/06/24/vim/"/>
    <id>http://9cat.top/2018/06/24/vim/</id>
    <published>2018-06-24T09:28:46.000Z</published>
    <updated>2018-06-24T09:33:48.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>vim<br>命令行模式，插入模式，末行模式<br>命令模式，不能输入字符<br><code>移动命令：</code><br>j        向下移动光标<br>k        向上移动光标<br>h        向左移动光标<br>l        向右移动光标<br>gg         文件顶部<br>G          文件末尾<br>数字gg 移动到数字对应行<br>数字G  移动到数字对应行<br>[        移动到段落首<br>]        移动到段落尾</p><p>Ctrl+b  向上翻页<br>Ctrl+f  向下翻页<br>H         屏幕顶部<br>M         屏幕中间<br>L         屏幕顶部</p><p>按i进入插入模式，可输入任意字符<br>按ESC退出插入模式<br>按：进入末行模式</p><p><code>撤销和取消撤销</code><br>u     ctrl+r</p><p><code>删除</code><br>x<br>n+x （n为数字）    删除N个字符<br>dd              删除光标所在行<br>D               一直删除至行尾<br>dw              删除选中之后直到空格<br>d+数字G          删除选中行到指定行</p><p><code>可视模式</code><br>按v：可视模式，可选中代码<br>按V：行<br>Ctrl+v：块<br>（可结合移动命令，例如：v+gg）</p><p>复制粘贴命令：<br>yy:复制整行代码<br>p:粘贴<br>yy19p  复制19行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>memory</title>
    <link href="http://9cat.top/2018/06/24/memory/"/>
    <id>http://9cat.top/2018/06/24/memory/</id>
    <published>2018-06-24T09:28:46.000Z</published>
    <updated>2018-07-01T01:37:00.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在C语言中，与其他编译语言一样，编译代码放入text段，而变量驻留在其他段中。<br>究竟是哪个存储器变量取决于变量如何定义。定义在所有函数之外的变量被认为是全局变量。<br>在任何变量前增加关键字static都会使该变量成为静态变量。<br>如果使用数据将静态变量或全局变量初始化了，它们就会存储在data内存段中，否则，这些变量就会存储在bss内存段中。<br>首先，必须使用用户名为malloc()的内存分配函数对对堆内存段中的内存进行分配。通常使用指针来引用堆中的内存。<br>最后，其余的函数变量存储在堆栈内存中。因为堆栈可以包含许多不同的栈帧，所以栈帧变量可以在不同的函数上下文内保持唯一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_var;</span><br><span class="line"><span class="keyword">int</span> global_initialized_var=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the function's stack_var is at addres 0x%08x\n"</span>,&amp;stack_var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> stack_var;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_initialized_var=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_var;</span><br><span class="line"><span class="keyword">int</span> *heap_var_ptr;</span><br><span class="line"></span><br><span class="line">heap_var_ptr=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"global_initialized_var is at addres 0x%08x\n"</span>,&amp;global_initialized_var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"static_initialized_var is at addres 0x%08x\n\n"</span>,&amp;static_initialized_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"static_var is at addres 0x%08x\n"</span>,&amp;static_var);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"global_var is at addres 0x%08x\n\n"</span>,&amp;global_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"heap_var is at addres 0x%08x\n\n"</span>,heap_var_ptr);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"static_var is addres 0x%08x\n"</span>,&amp;stack_var);</span><br><span class="line">function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="memory.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程编程基础</title>
    <link href="http://9cat.top/2018/06/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://9cat.top/2018/06/20/多线程编程基础/</id>
    <published>2018-06-20T09:45:55.000Z</published>
    <updated>2018-06-24T10:20:23.577Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ThreadProc \r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,ThreadProc,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"main \r\n"</span>);</span><br><span class="line"></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="programme" scheme="http://9cat.top/tags/programme/"/>
    
  </entry>
  
  <entry>
    <title>第一个win32汇编程序</title>
    <link href="http://9cat.top/2018/06/12/%E7%AC%AC%E4%B8%80%E4%B8%AAwin32%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/"/>
    <id>http://9cat.top/2018/06/12/第一个win32汇编程序/</id>
    <published>2018-06-12T11:58:55.000Z</published>
    <updated>2018-06-22T13:01:28.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Win32编程"><a href="#Win32编程" class="headerlink" title="Win32编程"></a>Win32编程</h1><p><code>This is code</code></p><p>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>        .386<br>        .model flat,stdcall<br>        option casemap:none<br>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>;文件定义<br>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>include        windows.inc<br>include     user32.inc<br>includelib     user32.lib<br>include     kernel32.inc<br>includelib    kernel32.lib<br>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>;数据段<br>        .data<br>szCaption    db    ‘来自酒猫’,0<br>szText        db    ‘Hello World’,0<br>szText_OK    db    ‘您刚点了OK按钮’<br>szCANCEL    db    ‘您刚点了CANCEL按钮’</p><p>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>;代码段<br>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>        .code<br>start:<br>        invoke    MessageBox,NULL,offset szCaption,MB_OKCANCEL or<br>        MB_INCONQUESTION<br>        cmp eax, IDOK<br>        je OK<br>        invoke    MessageBox,NULL,offset szCANCEL,offset szCaption,MB_OK<br>        jmp GO<br>OK:        invoke    MessageBox,NULL,offset szOK,offset szCaption,MB_OK<br>GO:        invoke    ExitProcess,NILL<br>;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>        end start<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Makefile</span><br><span class="line">-------</span><br></pre></td></tr></table></figure></p><p>EXE = hello.exe        #指定输出文件<br>OBJS = hello.obj        #需要的目标文件<br>RES = Fishc.res        #需要的资源文件</p><p>LINK_FLAG = /subsystem:windows    #连接选项<br>ML_FLAG = /c /coff        #编译选项</p><p>$(EXE): $(OBJS) $(RES)<br>    Link $(LINK_FLAG) $(OBJS) $(RES)</p><p>.asm.obj:<br>    ml $(ML_FLAG) $&lt;<br>.rc.res:<br>    rc $&lt;</p><p>clean:<br>    del <em>.obj<br>    del </em>.res</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>删除所有分区共享批处理</title>
    <link href="http://9cat.top/2018/05/28/%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA%E5%85%B1%E4%BA%AB/"/>
    <id>http://9cat.top/2018/05/28/删除所有分区共享/</id>
    <published>2018-05-28T11:58:55.000Z</published>
    <updated>2018-06-21T00:02:50.760Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="删除所有分区共享"><a href="#删除所有分区共享" class="headerlink" title="删除所有分区共享"></a>删除所有分区共享</h1><ul><li>先列举存在的分区，然后再逐个删除以分区命名的共享；</li><li>通过修改注册表防止admin$共享在下次开机时重新加载；</li><li>IPC$共享需要administritor权限才能删除</li></ul><p><code>This is code</code></p><pre><code>@echo offtitle 默认共享删除器echo.echo ----------------------------------------------echo.echo 开始删除每个分区下的默认共享echo.for %%a in (C D E F G H I J K L M N O P Q R S T U V W X Y Z) do @(    if exist %%a:\nul (        net share %%a$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 %%a$的默认共享 || echo 名为 %%a$的默认共享不存在        ))net share admin$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 admin$的默认共享 || echo 名为 admin$的默认共享不存在echo.echo ----------------------------------------------echo.net stop Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已停止net start Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已启动echo.echo ----------------------------------------------echo.echo 修改注册表以更改系统默认设置echo.echo 正在创建注册表文件echo Windows Registry Editor Version 5.00&gt; c:\delshare.reg:: 通过修改注册表禁止admin$共享，以防重启后再次加载echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt;c:\delshare.regecho &quot;AutoShareWks&quot;=dword:00000000&gt;&gt; c:\delshare.regecho &quot;AutoShareServer&quot;=dword:00000000&gt;&gt; c:\delshare.reg::删除IPC$共享，本功能需要administrator权限才能成功删除echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa]&gt;&gt; c:delshare.regecho &quot;restrictanonymous&quot;=dword:00000001&gt;&gt; c:\delshare.regecho 正在导入注册表以更改系统默认设置regedit /s c:\delshare.regdel c:\delshare.reg &amp;&amp; echo 临时文件已经删除echo.echo ----------------------------------------------echo.echo 程序已经成功删除所有的默认共享echo.echo 按任意键退出...pause&gt;nul</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
</feed>
