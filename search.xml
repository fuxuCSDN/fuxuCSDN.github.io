<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2Funcategorized%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程编程基础]]></title>
    <url>%2Funcategorized%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[#include &lt;windows.h&gt; #include &lt;stdio.h&gt; DWORD WINAPI ThreadProc(LPVOID lpParam) { printf(&quot;ThreadProc \r\n&quot;); return 0; } int main() { HANDLE hThread = CreateThread(NULL,0,ThreadProc,NULL,0,NULL); WaitForSingleObject(hThread, INFINITE); printf(&quot;main \r\n&quot;); CloseHandle(hThread); return 0; }]]></content>
      <tags>
        <tag>programme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个win32汇编程序]]></title>
    <url>%2Funcategorized%2F%E7%AC%AC%E4%B8%80%E4%B8%AAwin32%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Win32编程This is code1234567891011121314151617181920212223242526272829303132333435;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;数据段 .dataszCaption db &apos;来自酒猫&apos;,0szText db &apos;Hello World&apos;,0szText_OK db &apos;您刚点了OK按钮&apos;szCANCEL db &apos;您刚点了CANCEL按钮&apos;;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: invoke MessageBox,NULL,offset szCaption,MB_OKCANCEL or MB_INCONQUESTION cmp eax, IDOK je OK invoke MessageBox,NULL,offset szCANCEL,offset szCaption,MB_OK jmp GOOK: invoke MessageBox,NULL,offset szOK,offset szCaption,MB_OKGO: invoke ExitProcess,NILL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end start Makefile123456789101112131415161718EXE = hello.exe #指定输出文件OBJS = hello.obj #需要的目标文件RES = Fishc.res #需要的资源文件LINK_FLAG = /subsystem:windows #连接选项ML_FLAG = /c /coff #编译选项$(EXE): $(OBJS) $(RES) Link $(LINK_FLAG) $(OBJS) $(RES).asm.obj: ml $(ML_FLAG) $&lt;.rc.res: rc $&lt;clean: del *.obj del *.res]]></content>
  </entry>
  <entry>
    <title><![CDATA[删除所有分区共享批处理]]></title>
    <url>%2Funcategorized%2F%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[删除所有分区共享 先列举存在的分区，然后再逐个删除以分区命名的共享； 通过修改注册表防止admin$共享在下次开机时重新加载； IPC$共享需要administritor权限才能删除 This is code @echo off title 默认共享删除器 echo. echo ---------------------------------------------- echo. echo 开始删除每个分区下的默认共享 echo. for %%a in (C D E F G H I J K L M N O P Q R S T U V W X Y Z) do @( if exist %%a:\nul ( net share %%a$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 %%a$的默认共享 || echo 名为 %%a$的默认共享不存在 ) ) net share admin$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 admin$的默认共享 || echo 名为 admin$的默认共享不存在 echo. echo ---------------------------------------------- echo. net stop Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已停止 net start Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已启动 echo. echo ---------------------------------------------- echo. echo 修改注册表以更改系统默认设置 echo. echo 正在创建注册表文件 echo Windows Registry Editor Version 5.00&gt; c:\delshare.reg :: 通过修改注册表禁止admin$共享，以防重启后再次加载 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt;c:\delshare.reg echo &quot;AutoShareWks&quot;=dword:00000000&gt;&gt; c:\delshare.reg echo &quot;AutoShareServer&quot;=dword:00000000&gt;&gt; c:\delshare.reg ::删除IPC$共享，本功能需要administrator权限才能成功删除 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa]&gt;&gt; c:delshare.reg echo &quot;restrictanonymous&quot;=dword:00000001&gt;&gt; c:\delshare.reg echo 正在导入注册表以更改系统默认设置 regedit /s c:\delshare.reg del c:\delshare.reg &amp;&amp; echo 临时文件已经删除 echo. echo ---------------------------------------------- echo. echo 程序已经成功删除所有的默认共享 echo. echo 按任意键退出... pause&gt;nul]]></content>
  </entry>
  <entry>
    <title><![CDATA[VC++SOCK编程服务器端代码]]></title>
    <url>%2Funcategorized%2FsockServer%2F</url>
    <content type="text"><![CDATA[Winsock编程服务器端This is code #include &lt;stdio.h&gt; #include &lt;Winsock2.h&gt; void main() { //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) { return; } if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) { WSACleanup( ); return; } //创建用于监听的套接字 SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY); addrSrv.sin_family=AF_INET; addrSrv.sin_port=htons(6000); //绑定淘套接字 bind(sockSrv,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR)); //将套接字设置为监听，准备客户请求 listen(sockSrv,5); SOCKADDR_IN addrClient; int len=sizeof(SOCKADDR); while(1) { //等待客户请求到来 SOCKET sockConn=accept(sockSrv,(SOCKADDR*)&amp;addrClient,&amp;len); char sendBuf[100]; sprintf(sendBuf,&quot;Welcome %s to XXXX&quot;,inet_ntoa(addrClient.sin_addr)); //发送数据 send(sockConn,sendBuf,strlen(sendBuf)+1,0); char recvBuf[100]; //接受数据 recv(sockConn,recvBuf,100,0); //打印接受的数据 printf(&quot;%s\n&quot;,recvBuf); //关闭套接字 closesocket(sockConn); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[学习笔记：大O记法]]></title>
    <url>%2Funcategorized%2F%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大O记法C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。考虑一个数组，按照数组下标的到一个元素的引用int arr[100];int x = arr[88]; //这个算法就是O(1)的O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例考虑一个list链表list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。O(logN) 算法只花费logN个单位时间长度的时间。logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。O(log(一个亿))约等于19个单位时间的时长。O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[VC++SOCK编程客户器端代码]]></title>
    <url>%2Funcategorized%2FsockClient%2F</url>
    <content type="text"><![CDATA[Winsock编程客户端This is code #include &lt;stdio.h&gt; #include &lt;Winsock2.h&gt; void main() { //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) { return; } if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) { WSACleanup( ); return; } SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); SOCKADDR_IN addrSrv; addrSrv.sin_addr.S_un.S_addr=inet_addr(&quot;127.0.0.1&quot;); addrSrv.sin_family=AF_INET; addrSrv.sin_port=htons(6000); connect(sockClient,(SOCKADDR*)&amp;addrSrv,sizeof(SOCKADDR)); char recvBuf[100]; recv(sockClient,recvBuf,100,0); printf(&quot;%s\n&quot;,recvBuf); send(sockClient,&quot;This is zhangsan&quot;,strlen(&quot;This is zhangsan&quot;)+1,0); closesocket(sockClient); WSACleanup(); }]]></content>
  </entry>
</search>
