<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[缓冲区溢出练习]]></title>
    <url>%2F2018%2F07%2F01%2Fauth-overflow%2F</url>
    <content type="text"><![CDATA[缓冲区溢出漏洞从计算机出现初期就已经存在，并且今天仍然存在。尽管C语言的简单性增加了程序员的控制能力，提高了最后得到的程序的效率，但是程序员不小心的话，这种简单性会导致程序缓冲区溢出和存储器泄露这样的漏洞。这意味着一旦给某个变量分配了内存空间，则没有内置的安全机制来确保这个变量的容量能适应已分配的存储空间。如果程序员把10个字节的数据存入只分配了8个字节空间的缓冲区中，这种操作是允许的，即使这种操作很可能导致程序崩溃。这称为缓冲区超限(buffer overrun)或缓冲区溢出，由于多出的2个字节数据会溢出，存储在已分配的存储空间之外，因此会重写已分配存储空间之后的数据。如果重写的是一段关键数据，程序会崩溃。通过破坏内存来控制执行流程。程序auth_overflow.c演示了这个概念。123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int check_authentication(char *password)&#123;int auth_flag = 0;char password_buffer[16];strcpy(password_buffer,password);if(strcmp(password_buffer,"brillig")==0) auth_flag = 1;if(strcmp(password_buffer,"outgrabe")==0) auth_flag = 1; return auth_flag;&#125;int main(int argc,char *argv[])&#123; if(argc&lt;2) &#123; printf("Usage:%s&lt;password&gt;\n",argv[0]); exit(0); &#125; if(check_authentication(argv[1])) &#123; printf("\n-=-=-=-=-=-=-=-=\n"); printf("Access Granted.\n"); printf("\n-=-=-=-=-=-=-=-=\n"); &#125;else&#123; printf("\nAccess Denied.\n"); &#125;&#125; 这个示例程序接受一个密码作为它唯一的命令行参数，然后调用函数check_authentication()。这个函数允许两个密码，意味着它允许多重验证方法。如果使用网络两个密码中的一个，函数会返回1，这样会授予访问权限。在编译代码前，通过查看源代码，您应该能够推测出它的大部分功能。但在程序时，请使用-g选项，因为随后会对其进行调试。您也许早就推测出会发生什么，但让我们使用调试工具对它进行检查以查看其细节。使用-q选项会使得GDB调试工具取消欢迎标语，并在第10行和第17行设置了断点。程序运行时，会在断点处暂停并为我们提供一个检查内存的机会。第1个断点在strcpy()发生之前。通过检查password——buffer指针，调试工具显示它填充的是随机的未初始化的数据，位于内存中0xbffff5ec处。通过检查auth_flag变量的地址，我们可以看到他的存储位置0xbffff5fc和它的值0。可以使用打印命令做算术运算，它显示auth_flag位于password_buffer开始之后的16字节处。也可以在以password_buffer开始的一块内存中看到这种关系。继续运行到strcpy()之后的第2个断点，再次对这些存储单元进行检查。password_buffer溢出到auth_flag中，将它的前两个字节变为0x41。值0x00004141可能看起来是颠倒的，但是要记住x86采用的是小端存储方式。如果单独检查每个4字节单元，就可以看到内存实际上是如何排列的。最终，程序会将这个值看做一个整数，其值为1094795585。溢出之后，函数check_authentication()会返回1094795585，而不是0.因为if语句认为任何非0值都能通过验证，所以程序执行流程进入授权部分。在这个列子中，变量auth_flag是执行控制点，因此覆盖该值是实现控制的根源。]]></content>
      <categories>
        <category>溢出</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一位程序员的十年总结(转载)]]></title>
    <url>%2F2018%2F07%2F01%2F%E4%B8%80%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%8D%81%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告走过的路，回忆起来是那么曲折，把自己的一些心得体会分享给程序员兄弟姐妹们，虽然时代在变化，但是很可能你也会走我已经做过的10年的路程，有些心得体会你可以借鉴一下，觉得说得有道理的你就接纳，觉得说得没道理的，你就抛弃，以下是我发自内心的，给大家的忠告，特别是针对那些小弟弟妹妹们。 01. 自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。由于程序员行业每年跳槽一次，我不隐瞒大家，我至少换过5个以上的单位，这期间跳来跳去，甚至是城市都换过3个。还好户口没丢掉，其他都已经是乱了，好几个城市里，都有交过三金，甚至是一个城市的2个区里交的都有，那些东西，10年后，会变得很重要。你买房子若有公积金，可以取出来，贷款利率也会比较低一些，有孩子了，还需要上学，生病了还需要医疗保险。特别是买房子时，你要商业贷款与公积金贷款的利率差别还是很大，有可能会有10万的差距。你平时都注意这些，会给你带来的损失会最小，例如每个月缴纳300元的公积金，公司也缴纳300元，你一个月能存下来600元，一年就是7200元，10年就是72000元。我以前都忽视了这些，到我需要买房子时，公积金里可能只有几千元，10年很快就过去了，结果我没能存下来多少公积金，医疗保险，养老金等更别提了，都已经稀里糊涂了，这些损失10年累加起来，是很庞大的数字，大家要注意，跳槽换工作时也要保护好自身的利益，现在房价很贵，你可能是跟我一样，大山里出来打拼的娃子，家里也没有丰厚的积蓄，只有靠自己拼搏，买房子是人生的一件大事，等你到了10年，才想到这个事情，已经晚了，特别是孩子要上学，上幼儿园等，需要户口啥的都要齐全。 02. 不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。这方面我的经验教训也是惨痛的。我大概前后购买过5-6个笔记本，以前的都是1万多元一台，最近买的是一台是1万多给女朋友的，自己买了一台是7500元左右，手机大概换过接近10个了，这些钱加起来也足够有10万以上了，你可能一不小心就购买了这些电子产品，但是时间长了，你一回过头来想想，你为什么赚得也不少，但是为什么还是那么穷，是因为你购买这些电子产品花费了过多的金钱了，平时笔记本啥的贵重物品要保护好，我一个同事不小心丢了2台笔记本电脑，接近2万的损失啊，你净赚2万，不是那么容易的，这个窟窿不是开玩笑的，我曾经也被人偷了一个崭新的笔记本，损失1.5万左右，更糟糕的是最新的代码也丢被偷了。 03. 这年代外语、学历、职称、驾驶证还是蛮重要的。想找高薪，外资企业是正确的选择，在同样的打工里，外资企业的收入普遍是高的，我就想不明白，我们的赚钱能力怎么就比不过人家了，社会不断发展，将来可能去外国就像串门一样了，也说不定的，外语好将来的就业机会也会更多更广一些。学历并不代表啥，但是学历也是敲门砖，例如有300个应聘者，那至少重点本科以下的，统统不看了，因为实在是来不及看了，你再厉害也被挡在机会的门外了，同样有时候你想改行什么的，职称也很重要，最起码评个中级职称，说不定还有机会能进入大学或者政府部门还是有可能性。若有充裕的时间，应该把驾驶证考了，因为你越到后面越忙与工作家庭，没机会学车了也说不定的，平时也别光顾拼命工作，工作10年后你才发现，原来身边的人都至少硕士学历了，你被社会自动淘汰了，我现在就有这个感觉，虽然我带过很多硕士，他们的就业机会比我还好，经常能进入名牌企业，我也一直进不去。 04. 不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。我谈过2个女朋友，平均每个女朋友身上的开支前后大概会有10万左右，还好我不用谈第3个女朋友了，若投资失误，那也是很残忍的，谈女朋友也会消耗很多时间精力、还会消耗很多金钱，实话的讲的确是这样的，人家女孩子也值钱啊，凭什么就那么轻易的跟你啊，我跟第一个朋友分手时，我的生活至少是倒退了3-4年，一切从零开始，一切从头开始，我劝大家谈女朋友是人生最大的一笔买卖，投资失误会有惨痛的后果，不仅仅是金钱上的损失，更会有精神、心灵上的沉重打击，大家要学会珍惜女朋友，要学会哄好女朋友，让老婆开心每一天，虽然鱼儿上钩了，不用再下鱼饵了，偶尔也别忘记放点米，这个鱼要是脱钩了，那不是开玩笑的。 05. 工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。换工作，换行业方向，就像熊掰苞米一样的道理，有时候是丢了芝麻捡西瓜，有时候是丢了西瓜捡芝麻，这个道理我就不多讲了，大家都应该能明白的。 06. 要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。有个朋友的QQ名字很有意思，“只爱陌生人”，陌生人是很有意思，但是最关键时刻，还是需要靠非陌生人，你每天跟同事一起生活，要维系好身边的人。你的成功与失败，往往是你身边的30-40个人决定的。你就是世界首富，他身边也是那么不超过100个人的在左右着他的生活，当你工作10年了，没一个老板信任你，没几个要好的同事朋友，那你惨了，你在这个世界上已经是很孤单了，你的收入，其实大多是来自这些身边的朋友给你介绍的生意，不大会网上掉几个馅饼的。现在你身边的人有可能在不久的将来，给你提供很多好机会。 07. 钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。钱不是万能的，但是没钱是万万不能的。钱赚了，身体夸了，全送给医院了，钱赚了，身心疲惫了，人活着为了啥？不就为了开开心心生活嘛？工作重要，但是失去了家人的爱，失去了女朋友，失去了老婆孩子，那这个工作有啥用了？工作很容易就换了，家人是换不了的，老婆不是想换就换的，孩子不是想换就换的，连自己的家庭都不负责的人，怎么可能对公司负责呢？我一直是这个观念，来面试时觉得工作更重要的，我们一般不录取的，那太假了，或者太不懂事了。 08. 工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。时间一晃就过去了，工作累了是可以适当放松，但是别太贪玩，10年很容易就过去了，10年后你要买房子，要娶老婆，要买车子，要生娃娃，身体也会变得脆弱一些，需要良好的生活习惯，也经不起通宵了，通宵一次，你要低迷好几天才能缓过劲儿来，跟20刚出头完全不一样了，用钱的地方多了去了，父母也会变得更老一些，可能也需要你的照顾，整个家子都指望你赚钱，别到了这个时候，你才意识到赚钱是那么的重要，更何况现在城市的房价，动不动就是100万，加上按揭的利息，你很可能需要支付150万。还可能需要装修，买车子。可能你身上的压力是200万。别觉得谈钱就俗，你要学会赚钱，要有个需要赚钱的良好意识，当然你出身富裕家庭，就不用考虑这些因素了。 09. 每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。总有一天，你也会有累的时候，你也会有老的时候，这时候，你要靠啥呢？就要靠你平时的积累，你10年的积累，可以打倒很多竞争对手，他们再厉害，再怎么样，也很难抵得过你10年的积累，特别是后面5-10年的积累，成果会很明显，前面的1-5年，算是做软件的入门吧，除非你有高人指点，那可能2-3年就可以修成正果，软件在将来还是会值钱的，以为生活会越来越智能化，越来越数字化，软件的需求还是很有前途，最起码未来的10-20年里不用太担心失业问题了。 10. 对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。我大概7-8年前的代码都在手上，经常改进来改进去，维护来维护去，在一定的程度上，让我生活轻松了不少，因为我不用什么都从头来过，我只要痛苦一次，以后就要反复重复利用，软件的价值在于重复利用，而不是每个东西，都从头开发，那永远也是辛苦的程序员，这个生活质量就别提了，不管自己的代码丑还是拿不出手，要学会精心维护，每天改进一点点，每个月一个小进步，每年一个大进步，多年的积累是宝贵的，这个早晚也会给你带来丰厚的收益。 11. 当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。我有一个朋友跟我开玩笑，工作5年的人，可能能力差距会很大，为什么呢？因为第一年他们干的事情都是一样的，都写程序了，2个人可能由于价值观不一样，5年后差距会很大，甚至是大到无法追赶的程度，为啥？因为还有机会的因素在里面，有的人干了5年，还是在原地踏步，天天只会写那些添加、删除、修改的代码。那你得注意了，需要不断的提高自己，才是硬道理。例如你会SQLServer，那要试着学习Oracle， 你是做C/S的，那得需要提高到B/S的，你是做单机软件的，那得需要提高到网络软件，你只关注自己的工作的，需要学会管理，关心他人的工作。你是当程序员的，要试着提高当项目经理、部门经理，公司的总监等等，人有野心有目标才会不断进步，最俗的为了多赚钱，提高工作职位工作岗位，工作单位，也是可以理解的。年纪越大工作越难找，例如3-4千的工作是随便找找，玩一样，但是你30过后，最起码要找月薪上1万的工作，这样的工作是机会也少，一般小公司也给不起，还得找个好公司才可以，好公司又不是天天招聘人，天天缺好的工作岗位，说不好听点儿，小公司的老板才赚多少啊？他来钱也很不容易的，小池塘就不好容得下大鲨鱼了。 12.当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。创业的收入，比打工还少，那就是瞎扯蛋，恶搞。创业的真正意思并不是要你去吃苦没钱赚，那是忽悠无知的人的。当你创业时的收入，比打工还多，那你可以考虑创业，没有工资什么的，股份啥的，都是瞎扯蛋。不要跟自己能力还弱的人一起创业，那损失最大的，很可能就是你，要创业，也要找比自己强的人一起创业，最起码赚不到钱，还能学到不少。不会有过多的损失。别热血一沸腾就创业了，创业了，也别烧自己的钱，家人的钱，那是很不抗烧的，没几下几十万就烧干了。其实打工，也是创业的开始，每个月都能拿到钱，还可以学到知识，什么公司的股份都是空话，没几个小公司能成功，开起来了也走不了3年就分家了，都忽悠小孩子玩的，除非真的有科技含量或者是客户资源的，否则股份是一文钱不值的，就算创业每个月也按时拿工资才是硬道理。 13. 未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。在未来，我们享受良好的服务的同时，也会为别人提供更良好的服务，需要在技能上还是服务质量上的要求会更高更严格。平时要注意提高自己，不要被时代淘汰掉，我从小的朋友，一波又一波被社会无情的淘汰了，很小的时候，我出生在大草原与大山的交界处，我小时候的玩伴，还在大山里，我跟着家人杀出来了，我小学、中学、大学、工作上的、这10年，我一直很坚强的拼搏下来，很不容易的在杭州立住脚了，说实话，参加工作后的十年，也是不断拼搏，不断提高的十年。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2.1.3Winsock网络编程知识（下）]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-3Winsock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[！上接Winsock网络编程知识（上）！sockaddr结构体是为了保持各个特定协议之间的兼容性而设计的。为bind()函数指定的地址和端口时，向sockaddr_in结构体填充相应的内容，而调用函数时应该使用sockaddr结构体。在sockaddr_in结构体中，还有一个结构体in_addr，该结构体在winsock2.h中的定义如下:1234567struct in_addr&#123; union &#123; struct &#123; u_char s_bl,s_b2,s_b3,s_b4; &#125; S_un_b; struct &#123; u_short s_wl,s_w2; &#125; S_un_w; u_long S_addr; &#125;S_un;&#125;; 该结构体是一个共用体S_un，包含2个结构体变量和1u_long类型变量。一般使用的IP地址的数据类型是使用点分十进制表示的,而in_addr结构体中却没有提供用来保存点分十进制表示IP地址的数据类型，只是需要使用转换函数，把点分十进制表示的IP地址转换成in_addr结构体可以接受的类型。这里使用的转换函数是inet_addr(),该函数的定义如下：1unsigned long inet_addr(const char FAR *cp); 该函数是将点分十进制表示的IP地址转换成unsigned long类型的数值。该函数的参数cp是指向点分十进制IP地址的字符指针。同时该函数也是一个逆函数，是将unsigned long型的数值型IP地址转换成点分十进制的IP地址，该函数的定义如下：1char FAR * inet_ntoa(struct in_addr in); sockaddr_in结构体中的sin_port表示端口，这个端口需要使用大尾方式字节序存储（也称大端和小端，是两种不同的存储方式。）在intel X86架构下，数值存储方式默认W为小尾方式字节序，而TCP/IP的数值的存储方式都是大尾方式的字节序。为了实现方便的转换，winsock2.h中提供为了方便的函数，即htons()和htonl()两个函数，并且提供了他们的逆函数ntohs()和ntohl()。htons()和htonl()函数的定义分别如下：12u_short htons(u_short hostshort);u_long htonl(u_long hostlong); ntohs()和ntohl()函数的定义分别如下：12u_short ntohs(u_short netshort);u_long ntohl(u_long netlong); 这4个函数中，前两个函数是将主机字节序转换成网络字节序，后两个是将网络字节序转换成主机字节序。在有些架构系统下，主机字节序和网络字节序是相同的，那么转换函数不进行任何转换，但是为了代码的移植性，还是会进行转换函数的调用。具体的bind()函数的使用方法如下：12345678910//创建套接字SOCKET sListen = socket(PF_INEF, SOCK_STREAM, IPPROTO_TCP);//对sockaddr_in结构体填充地址、端口等信息struct sockaddr_in ServerAddr;ServerAddr.sin_family = AF_INEF;ServerAddr.sin_addr.S_un.S_addr = inet_addr("10.10.30.16");ServerAddr.sin_port = htons(1234);//绑定套接字与地址信息bind(sLisent, (SOCKADDR *)&amp;ServerAddr, sizeof(serverAddr)); PS:对于服务器的地址可以指定为INADDR_ANY宏，表示“任意地址”或者“所有地址”。当客户端发起连接时。服务器操作系统接收到客户端的连接，根据网络的配置情况会自动选择一个IP地址和客户端进行通信。当套接字与地址端口信息绑定后，就需要让端口进行监听，当端口进行监听状态以后就可以接受其他主机的连接了。监听端口和接受连接请求的函数分别为listen()和accept()。监听端口的函数定义如下：1int listen(SOCKET s, int backlog); 该函数有两个参数，第1个参数s是指定要监听的套接字描述符，第2个参数是backlog是允许进入请求连接队列的个数，backlog的最大值由系统指定，在winsock2.h中，其最大值由SOMAXCONN表示，该值的定义如下：1#define SOMAXCONN 0x7fffffff 接受连接请求的函数定义如下：1SOCKET accept(SOCKET s,struct sockaddr FAR *addr, int FAR *addrlen); 该函数从连接请求队列中获取连接信息，创建新的套接字描述符，获取客户端地址。新创建的套接字用于和客户端进行通信。该函数有3个参数，第1个参数s是处于监听套接字描述符，第2个参数addr是一个指向sockaddr结构体的指针，用来返回客户端的地址信息，第3个参数addrlen是一个指向int型的指针变量，用来传入sockaddr结构体的大小。上面介绍的是面向连接的服务器端的函数，完成了一系列服务器应有的基本动作，如下： 首先，bind()函数将套接字描述符与地址信息进行绑定； 其次，listen()函数将套接字描述符置于监听状态； 最后，accept()函数获取连接队列中的连接信息，创建新的套接字描述符，以便与客户端通信。面向连接的客户端只需要完成与服务器的连接这样一个动作就可以实现和服务器的通信了。创建套接字描述符后，使用connect()函数就可以完成与服务器的连接。connet函数的定义如下：1int connet(SOCKES s, const struct sockaddr FAR *name,int namelen); 该函数的作用是将套接字进行连接。该函数有3个参数，第1个参数表示创建好的套接字描述符，第2个参数name是指向sockaddr结构体的指针，sockaddr结构体中保存了服务器的IP和端口号，第3个参数namelen是指定sockaddr结构体的长度。当客户端使用connect()函数与服务器连接后，客户端和服务器就可以通信了。通信时主要就是信息的发送和接收。这里介绍的函数有两个，分别是send()和recv()。发送函数send()的定义如下：1int recv(SOCKET s, const char FAR *buf, int len, int flags); 该函数有4个参数，第1个参数s是accept()函数返回的套接字描述符，第二个参数buf是发送消息的缓冲区，第3个参数len是缓冲区的长度，第4个参数flags通常赋值为0值。接收函数recv()的定义如下：1int recv(SOCKET s,char FAR *buf,int len, int flags); 该函数有4个参数，该函数的使用方法和send()函数的使用方法相同。这里不再介绍。 4.非面向连接协议的函数在面向连接的TCP协议中，服务器端将套接字描述符与地址进行绑定后，需要将端口进行监听，等待接受客户端的连接请求，而在客户端则需要连接服务器，完成这些步骤就可以保证面向连接的TCP协议的可靠传输，在调用connect()函数的过程中也完成了TCP的“三次握手”的过程。非面向连接的UDP协议在开发上基本与面向连接TCP相同。在非面向连接的UDP协议开发中服务器端不需要对端口进行监听，也就不需要等待接受客户端的连接请求，而客户端也不需要完成与服务器的连接。中间的“三次握手”过程也就省略了，这样UDP协议现对于TCP协议来讲就显得不可靠，但是效率会更高。（游戏方面一般采用DUP协议）在非面向连接协议开发中，服务器端不再调用listen()、accept()函数，客户端不再需要调用connect()函数。而服务器和客户端的通信换为sendto()和recvfrom()函数即可。sendto函数的定义如下：12345678int sendto( SOCKET s, const char FAR *buf, int len, int flags, const struct sockaddr FAR *to, int tolen); 该函数是用来在UDP协议通信双方进行发送数据的函数，该函数有6个参数，第1个参数s是套接字描述符，第2个参数buf是要发送数据的缓冲区，第3个参数len是指定第2个参数的长度，第4个参数通常赋0值，第5个参数to是一个指向sockaddr结构体的指针，这里给出接收信息的地址信息，第6个参数tolen是指定第5个参数的长度。recvfrom()函数的定义如下：12345678int recvfrom( SOCKET s, const char FAR *buf, int len, int flags, const struct sockaddr FAR *from, int FAR *fromlen); 该函数是用来在UDP协议通信双方进行接收数据的函数。该函数的用法与sendto()相同，这里不再介绍。PS：在缓冲区后设置数据的长度是为了防止缓冲区溢出！]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Winsock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3Winsock网络编程知识（上）]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-3Winsock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.Winsock的初始化与释放在使用winsock相关函数时需要对Winsock库进行初始化，而在使用完后需要对Winsock库进行释放。 Winsock库的初始化函数的定义如下：1int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); 该函数的第1个参数wVersionRequested是需要初始化的Winsock库的版本号，Winsock库有多个版本号，目前常用的版本是2.2.第二个参数lpWSAData是一个指向WSADATA的指针。该函数的返回值为0，说明该函数调用成功。如果调用失败，则返回其他值。在程序的开始处调用该初始化函数，在程序中就可以使用Winsock相关的所有API函数。 Winsock库的释放函数的定义int WSACleanup(void);该函数没有参数，在程序的结束处直接调用该函数，即可释放Winsock库。 2.套接字的创建与关闭套接字用于根据指定的协议类型来分配一个套接字描述符。该描述符主要用在客户端和服务器端进行通信，当套接字使用完毕时应该关闭套接字以释放资源。创建套接字与关闭套接字的函数为socket()和closesocket()。 创建套接字的函数定义如下：1SOCKET socket(int af,int type, int protocol); socket()函数共有3个参数，第1个参数af用来指定地址族，在Windows下可以使用的参数有很多个，但是真正可以使用的只有两个，分别说AF_INET和PF_INET。这两个宏在Winsock2.h下的定义相同，分别如下：123456#define AF_INET 2 /* internetwork:UDP, TCP, etc. *//** Protocol families,same as address families for now*/#define PF_INEF AF_INEF 以上两个定义都摘自Winsock2.h头文件。从定义来看，PF_INEF和AF_INEF是相同的。看PF_INEF宏定义上面的注释，AF表示地址族（Address Family）,而PF表示协议族（Protocol Family）。对于Windows来说，两者相同；对于Unix/Linux来说，两者是不同的。一般情况下，调用socket()函数时应使用PF_INEF，而在设置地址时使用AF_INEF。sock()函数的第2个参数type是指定新套接字描述符的类型。这里可以使用的值通常有3个，分别是SOCK_STREAM、SOCK_DGRAM和SOCK_RAW，分别表示流套接字、数据包套接字和原始协议接口。socket()函数的第3个参数Protocol用来指定程序所使用的通信协议，这里可以选择使用IPPROTO_TCP、IPPROTO_UDP、IPPROTO_ICMP等协议，这个参数的值是根据第2个参数的值进行选择。第2个参数如果使用SOCK_STREAM，那么第3个参数应该使用IPPROTO_TCP；如果第2个参数使用SOCK_DGRAM，那么第3个参数应该使用IPPROTO_UDP。也就是说，如果第2个参数是SOCK_STREAM或SOCK_DGRAM，那么第3个参数可以默认为0.如果第2个参数指定的是SOCK_RAW，那么第3个参数必须指定，而不能使用0值。socket()函数调用成功返回值为一个新的套接字描述符，如果调用失败，则返回INVALID_SOCKET。调用失败后，想要知道原因，那么紧接着调用WSAGetLastError()函数得到错误码。PS：所有的Winsock函数出错后都可以调用WSAGetLastError()得到错误码。 关闭套接字的函数定义如下：1int closesocket(SOCKET s); closesocket()函数是socket()函数创建的套接字描述符。PS：对于WSAStartup()/WSACleanup()和socket()/closesocket()这样的函数，最好保持成对出现。也就是说，在写完一个函数时，立刻写出另外一个函数的调用，以免忘记资源的释放。 3.面向连接协议的函数前面的部分提到了面向连接协议与非面向连接协议所用到的函数是不相同的。这里来介绍面向连接的函数：bind()、listen()、accept()、send()和recv()。这些函数是常用的面向连接的函数，只是一个基础。Winsock库的函数非常多，这里只是寥寥几个而已，下面介绍函数的使用方法。通过socket()函数可以直接创建一个新的套接字描述符，但是它只是一个描述符，为网络的一些资源做准备。要想真正在网络上进行通信，需要本地的地址与本地的端口号信息。当然，本地的地址与端口号信息需要和套接字描述符进行关联，进行绑定。在Winsock函数中，使用bind()函数完成套接字与地址端口信息的绑定。bind()函数的定义如下：1int bind(SOCKET s, const struct sockaddr FAR *name, int namelen); 该函数有3个参数，第1个参数s是新创建的套接字描述符，也就是用socket()函数创建的描述符，第2个参数name是一个sockaddr的结构体，提供套接字一个地址和端口信息，第3个参数namelen是sockaddr结构体的大小。其中第二个参数sockaddr结构体的定义如下：1234struct sockaddr&#123; u_short sa_family； /* address family */ char sa_data[14]; /* up to 14 bytes of direct address */&#125;； 该结构体共有16个字节，在该结构体之前所使用的协议为sockadd_in，该结构体的定义如下:123456struct sockadd_in&#123;short sin_family;u_short sin_port;struct in_add sin_addr;char sin_size[8];&#125;; ！未完待续！]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Winsock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2面向与非面连接协议所使用的函数]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-2%E9%9D%A2%E5%90%91%E4%B8%8E%E9%9D%9E%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.面向连接的协议在面向连接的协议中，两台计算机之间在进行数据收发前，必须先在两者之间建立一个通信通道，以确保两台计算机之间存在一条路径可以相互沟通。在数据传输完毕之后，切断这条通信通道。该种方式相当于打电话。面向连接的协议使用的是TCP协议，服务器与客户端建立通信信道所需要的基本Winsock函数如下： 服务器端函数：socket()-&gt;bind-&gt;listen()-&gt;accept()-&gt;send()/recv()-&gt;closesocket() 客户端函数：socket()-&gt;connet()-&gt;send()/recv()-&gt;closesocket() 2.非面向连接的协议在非面向连接的协议中，发送端只要直接将要发送的数据传出即可，不需要理会接送方是否能够接收到数据。而接受端在接受数据时，也不会响应消息通知发送给发送端。该种方式相当于写信，将写好的信放到信箱中，但是却不能保证收信人真的能够收到这封信。非面向连接使用的是UDP协议，服务器与客户端通信所需要的基本Winsock函数如下： 服务器端函数：socket()-&gt;bind-&gt;sendto()/recvfrom()-&gt;closesocket() 客户端函数：socket()-&gt;sendto()/recvfrom()-&gt;closesocket()]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1网络基础知识]]></title>
    <url>%2F2018%2F07%2F01%2F2.1.1%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[各种计算机之间通过互联网进行通信主要依靠TCP/IP协议。该协议分为4层，由上到下分别为应用层、传输层、网际层和链路层。TCP/IP协议总是下层为上层协议服务，下层协议的细节对上层协议来说是透明的。TCP/IP协议在每层协议中都定义了非常多的不同的协议，比如网际层的ICMP协议、IGMP协议，传输层的TCP协议、UDP协议等。在众多协议中，最具有代表性的是TCP/IP协议。 IP协议是“Internet Protocol”的简称，它是计算机网络相互连接进行通信而设计的协议。在IP协议中最重要的就是IP地址，IP地址是用来在网络上唯一标识一台计算机主机的地址。互联网中没有两个机器有相同的IP地址，因此它是用来标识一台网络主机的。所有的IP地址都是32位长，它用点分十进制表示，比如“10.10.30.16”。IP地址指定的不是主机，而是网络接口设备。因此，一台主机有两个网络接口，那么就会有两个IP地址。通常情况下，对于一台普通主机只有一个网络接口设备，也就只有一个IP地址。比如：个人使用的PC通常只有一个IP地址；而对于服务器来说，则会有多个网络接口设备，每个网络接口设备都有一个IP地址，比如WEB服务器可能就会有多个IP地址。 IP地址被分为5类，分别是A类、B类、C类、D类和E类。各类IP地址范围如下所示。 传输层有两大协议，分别是TCP协议和UDP协议。TCP协议是“Transmission Control Protocol”的简称，其意思是传输层控制协议。TCP协议是一种面向连接的、可靠的通信协议。TCP协议是IP协议的上层协议，IP协议服务于TCP协议。UDP协议是“User Datagram Protocol”的简称，其意思为用户包协议。UDP协议是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。传输层是为应用层提供服务的，应用层的协议一部分是基于TCP协议的，比如FTP、HTTP。而一部分是基于UDP的，比如DNS协议。IP层提供了IP地址用来标识网络主机，而传输层提供端口来标识主机中的进程。确定了IP地址和端口号，就确定了网络上的主机以主机上通信的进程。传输层提供了标识通信进程的端口号。按照协议划分，端口号分为TCP端口和UDP端口，TCP端口和UDP端口各有65536个。对于应用程序而言，一般使用大于1024的端口号，因为小于1024的端口属于保留端口。Internet上的很多服务都是用小于1024的端口号。为避免冲突，程序员自己编写的应用程序不要使用小于1024的端口号。同一协议的端口不能冲突，比如Web服务器占用主机TCP协议的80端口，那么另外的程序就不可以再使用TCP协议的80端口。常见的端口号如下图所示。除了小于1024端口号外，还有一些比较有名的端口号，比如MY SQL Server的端口号是1433，Windows的远程桌面端口号是3389等。程序员在编写自己的网络应用程序时，要避免与这些常用端口冲突。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大O记法]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大O记法C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。考虑一个数组，按照数组下标的到一个元素的引用int arr[100];int x = arr[88]; //这个算法就是O(1)的O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例考虑一个list链表list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。O(logN) 算法只花费logN个单位时间长度的时间。logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。O(log(一个亿))约等于19个单位时间的时长。O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。]]></content>
      <tags>
        <tag>算法和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP调试工具]]></title>
    <url>%2F2018%2F06%2F24%2FIP%2F</url>
    <content type="text"><![CDATA[dos下的一些命令netstat -s -p tcp/udp/icmp/ip ping -l 65500 -t 192.168.1.1 #死亡之ping for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.1.%i #批处理ping for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.2.%i nbtstat -a 192.168.1.106 探测主机名 add portopening protocol =all port=135 name=关闭135端口 mode=enable SCOP=Subnet netsh advfirewall firewall add portopening protocol =tcp port=55555 name重要服务 mode=enable delete portopening protocol =tcp port=55555 interface=重要服务 delete portopening TCP 135]]></content>
  </entry>
  <entry>
    <title><![CDATA[memory]]></title>
    <url>%2F2018%2F06%2F24%2Fmemory%2F</url>
    <content type="text"><![CDATA[在C语言中，与其他编译语言一样，编译代码放入text段，而变量驻留在其他段中。究竟是哪个存储器变量取决于变量如何定义。定义在所有函数之外的变量被认为是全局变量。在任何变量前增加关键字static都会使该变量成为静态变量。如果使用数据将静态变量或全局变量初始化了，它们就会存储在data内存段中，否则，这些变量就会存储在bss内存段中。首先，必须使用用户名为malloc()的内存分配函数对对堆内存段中的内存进行分配。通常使用指针来引用堆中的内存。最后，其余的函数变量存储在堆栈内存中。因为堆栈可以包含许多不同的栈帧，所以栈帧变量可以在不同的函数上下文内保持唯一。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int global_var;int global_initialized_var=5;void function()&#123; int stack_var; printf("the function's stack_var is at addres 0x%08x\n",&amp;stack_var);&#125;int main()&#123; int stack_var; static int static_initialized_var=5; static int static_var; int *heap_var_ptr; heap_var_ptr=(int *)malloc(4); printf("global_initialized_var is at addres 0x%08x\n",&amp;global_initialized_var); printf("static_initialized_var is at addres 0x%08x\n\n",&amp;static_initialized_var); printf("static_var is at addres 0x%08x\n",&amp;static_var); printf("global_var is at addres 0x%08x\n\n",&amp;global_var); printf("heap_var is at addres 0x%08x\n\n",heap_var_ptr); printf("static_var is addres 0x%08x\n",&amp;stack_var); function();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2018%2F06%2F24%2Fvim%2F</url>
    <content type="text"><![CDATA[vim命令行模式，插入模式，末行模式命令模式，不能输入字符移动命令：j 向下移动光标k 向上移动光标h 向左移动光标l 向右移动光标gg 文件顶部G 文件末尾数字gg 移动到数字对应行数字G 移动到数字对应行[ 移动到段落首] 移动到段落尾 Ctrl+b 向上翻页Ctrl+f 向下翻页H 屏幕顶部M 屏幕中间L 屏幕顶部 按i进入插入模式，可输入任意字符按ESC退出插入模式按：进入末行模式 撤销和取消撤销u ctrl+r 删除xn+x （n为数字） 删除N个字符dd 删除光标所在行D 一直删除至行尾dw 删除选中之后直到空格d+数字G 删除选中行到指定行 可视模式按v：可视模式，可选中代码按V：行Ctrl+v：块（可结合移动命令，例如：v+gg） 复制粘贴命令：yy:复制整行代码p:粘贴yy19p 复制19行]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程编程基础]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; printf("ThreadProc \r\n"); return 0;&#125;int main()&#123; HANDLE hThread = CreateThread(NULL,0,ThreadProc,NULL,0,NULL); WaitForSingleObject(hThread, INFINITE); printf("main \r\n"); CloseHandle(hThread); return 0;&#125;]]></content>
      <tags>
        <tag>programme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个win32汇编程序]]></title>
    <url>%2F2018%2F06%2F12%2F%E7%AC%AC%E4%B8%80%E4%B8%AAwin32%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Win32编程This is code ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;数据段 .dataszCaption db ‘来自酒猫’,0szText db ‘Hello World’,0szText_OK db ‘您刚点了OK按钮’szCANCEL db ‘您刚点了CANCEL按钮’ ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: invoke MessageBox,NULL,offset szCaption,MB_OKCANCEL or MB_INCONQUESTION cmp eax, IDOK je OK invoke MessageBox,NULL,offset szCANCEL,offset szCaption,MB_OK jmp GOOK: invoke MessageBox,NULL,offset szOK,offset szCaption,MB_OKGO: invoke ExitProcess,NILL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end start12Makefile------- EXE = hello.exe #指定输出文件OBJS = hello.obj #需要的目标文件RES = Fishc.res #需要的资源文件 LINK_FLAG = /subsystem:windows #连接选项ML_FLAG = /c /coff #编译选项 $(EXE): $(OBJS) $(RES) Link $(LINK_FLAG) $(OBJS) $(RES) .asm.obj: ml $(ML_FLAG) $&lt;.rc.res: rc $&lt; clean: del .obj del .res]]></content>
  </entry>
  <entry>
    <title><![CDATA[删除所有分区共享批处理]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[删除所有分区共享 先列举存在的分区，然后再逐个删除以分区命名的共享； 通过修改注册表防止admin$共享在下次开机时重新加载； IPC$共享需要administritor权限才能删除 This is code @echo off title 默认共享删除器 echo. echo ---------------------------------------------- echo. echo 开始删除每个分区下的默认共享 echo. for %%a in (C D E F G H I J K L M N O P Q R S T U V W X Y Z) do @( if exist %%a:\nul ( net share %%a$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 %%a$的默认共享 || echo 名为 %%a$的默认共享不存在 ) ) net share admin$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 admin$的默认共享 || echo 名为 admin$的默认共享不存在 echo. echo ---------------------------------------------- echo. net stop Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已停止 net start Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已启动 echo. echo ---------------------------------------------- echo. echo 修改注册表以更改系统默认设置 echo. echo 正在创建注册表文件 echo Windows Registry Editor Version 5.00&gt; c:\delshare.reg :: 通过修改注册表禁止admin$共享，以防重启后再次加载 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt;c:\delshare.reg echo &quot;AutoShareWks&quot;=dword:00000000&gt;&gt; c:\delshare.reg echo &quot;AutoShareServer&quot;=dword:00000000&gt;&gt; c:\delshare.reg ::删除IPC$共享，本功能需要administrator权限才能成功删除 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa]&gt;&gt; c:delshare.reg echo &quot;restrictanonymous&quot;=dword:00000001&gt;&gt; c:\delshare.reg echo 正在导入注册表以更改系统默认设置 regedit /s c:\delshare.reg del c:\delshare.reg &amp;&amp; echo 临时文件已经删除 echo. echo ---------------------------------------------- echo. echo 程序已经成功删除所有的默认共享 echo. echo 按任意键退出... pause&gt;nul]]></content>
  </entry>
</search>
