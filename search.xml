<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CCTYPE函数系列]]></title>
    <url>%2F2018%2F07%2F19%2FCCTYPE%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[C++中应该是#include c中应该是#include &lt;ctype.h&gt;以下为字符库中常用的函数 函数名称 返回值 isalnum() 如果参数是字母数字，即字母或数字，该函数返回true isalpha() 如果参数是字母，该函数返回真 isblank() 如果参数是空格或水平制表符，该函数返回true iscntrl() 如果参数是控制字符，该函数返回true isdigit() 如果参数是数字（0～9），该函数返回true isgraph() 如果参数是除空格之外的打印字符，该函数返回true islower() 如果参数是小写字母，该函数返回true isprint() 如果参数是打印字符（包括空格），该函数返回true ispunct() 如果参数是标点符号，该函数返回true isspace() 如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true isupper() 如果参数是大写字母，该函数返回true isxdigit() 如果参数是十六进制的数字，即0～9、a~f、A~F，该函数返回true tolower() 如果参数是大写字符，则返回其小写，否则返回该参数 toupper() 如果参数是小写字母，则返回其大写，否则返回该参数 常用的有： tolower()————toupper() isupper()————islower() isalnum()————isalpha() 1.编写一个程序，读取键盘输入，直到遇到@符号为止，并回显输入（数字除外），同时将大写字母转换为小写，将小写字母转换为大写 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cctype&gt;int main()&#123; using namespace std; cout &lt;&lt; "Please enter: \n"; char ch; cin.get(ch); while(ch!='@') &#123; if(isdigit(ch)) cin.get(ch); else &#123; if(islower(ch)) ch=toupper(ch); else ch=tolower(ch); cout&lt;&lt;ch; cin.get(ch); &#125; &#125; return 0;&#125; 等价123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; char ch; cout &lt;&lt; "Please enter: \n"; while(cin.get(ch) &amp;&amp; ch!='@') &#123; if(islower(ch)) &#123; ch = toupper(ch); cout &lt;&lt; ch; &#125; else if(isupper(ch)) &#123; ch = tolower(ch); cout &lt;&lt; ch; &#125; &#125; return 0;&#125; 2.编写一个程序，最多将10个donation值读入到一个double数组中。程序遇到非数字输入时将结束输入，并报告这些数字的平均值以及数组中多少个数字大于平均值。123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; double sum=0,average=0; double num[10]; int i=0,total=0; cout &lt;&lt;"Please enter: \n"; double temp; while(cin&gt;&gt;temp&amp;&amp;i&lt;9&amp;&amp;!isdigit(temp)) &#123; num[i]=temp; sum+=num[i]; ++i; &#125; if(i!=0) average=sum/i; for(int j=0;j&lt;i;++j) if(num[j]&gt;average) ++total; cout&lt;&lt;"这些数字的平均值为："&lt;&lt;average&lt;&lt;endl; cout&lt;&lt;"并且共有"&lt;&lt;total&lt;&lt;"个数字大于平均值。\n"; return 0;&#125;]]></content>
      <tags>
        <tag>cctype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记：I/O读操作]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AI-O%E8%AF%BB%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[要运行下面的程序，首先得创建一个包含数字的文本文件。为此，可以用使用文本编辑器（如用于编写源代码的文本编辑器）。假设该文件为名scores.txt，包含的内容如下：1218 19 18.5 13.5 14 16 19.5 20 18 12 18.5 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;const int SIZE = 60;int main()&#123; using namespace std; char filename[SIZE]; ifstream inFile; //object for handing file input cout&lt;&lt;"Enter name of data file: "; cin.getline(filename,SIZE); inFile.open(filename); //associate inFile with a file if (!inFile.is_open()) //failed to open file &#123; cout&lt;&lt;"Could not open the file "&lt;&lt;filename &lt;&lt;endl; cout&lt;&lt;"Program terminating.\n"; exit(EXIT_FAILURE); &#125; double value; double sum = 0.0; int count = 0; //number of items read inFile &gt;&gt; value; //get first value while (inFile.good()) //whiel input good and not at EOF &#123; ++count; //one more item read sum+=value; //calculate running total inFile&gt;&gt;value; // get next value &#125; if (inFile.eof()) cout&lt;&lt;"End of file reached.\n"; else if (inFile.fail()) cout&lt;&lt;"Input terminated by data mismatch.\n"; else cout&lt;&lt;"Input terminated for unknown reason.\n"; if (count == 0) cout&lt;&lt;"No data processed.\n"; else &#123; cout&lt;&lt;"Intem read: "&lt;&lt;cout&lt;&lt;endl; cout&lt;&lt;"Sum: "&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;"Average: "&lt;&lt;sum / count &lt;&lt; endl; &#125; inFile.close(); //finished with the file return 0;&#125; 程序说明该程序没有使用硬编码文件名，而是将用户提供的文件名存储到字符数组filename中，然后该数组用作open()的参数：1inFile.open(fielname); 检查文件是否被打开至关重要。下面是一些可能出问题的地方：指定的文件可能不存在；文件可能位于另一个目录（文件夹）中；访问可能拒绝；用户可能输错了文件名或省略了文件扩展名。很多初学者花了大量的时间检查文件读取循环的哪里出了问题后，最终却发现问题在于程序没有打开文件。检查文件是否被成功打开可避免这种精力放在错误地方的情况发生。需要注意的是文件读取循环的正确设计。读取文件时，有几点需要检查。首先，程序读取文件时不应超过EOF。如果最后一次读取数据时遇到EOF，方法eof()将返回true。其次，程序可能遇到类型不匹配的情况。例如，下面程序期望文件中只包含数字。如果最后一次读取操作中发生了类型不匹配的情况，方法fail()将返回true（如果遇到EOF，该方法也将返回true）。最后，可能出现意外的问题，如文件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法bad()将返回true。不要分别检查这些情况，一种更简单的方法是使用good()方法，该方法在没有发生任何错误时返回true：1234while (inFile.good()) //while input good and not at EOF&#123; ...&#125; 然后，可以使用其他方法来确定循环终止的真正原因：123456if (inFile.eof()) cout&lt;&lt;"Enter of file reached.\n";else if (inFiel.fail()) cout&lt;&lt;"Input terminated by data mismatch .\n";else cout &lt;&lt; "Input terminated for unknown reason.\n"; 这些代码紧跟在循环的后面，用于判断循环为何停止。由于eof()只能判断是否到达EOF，而fail()可用于检查EOF和类型不匹配，因此上述代码首先判断是否到达EOF。这样，如果执行到了else if 测试，便可排除EOF，因此，如果fail()返回true，便可断定导致循环终止的原因是类型不匹配。方法good()指出最后一次读取输入的操作是否成功，这一点至关重要。这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标方法是，在循环之前（首次执行循环前）放置一条输入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句：1234567// standard file-reading loop designinFile &gt;&gt; value; //get first valuewhile (inFile.good()) //while input good and not at EOF&#123; //loop body goes here inFile &gt;&gt; value; //get next value&#125; 鉴于以下事实，可以对上述代码进行精简：表达式inFile&gt;&gt;value的结果为inFiel，而在需要一个bool值的情况下，inFile的结果为inFile.good()，即true或false。因此，可以将两条输入语句用一条用作循环测试的输入语句代替。也就是说，可以将上述循环结构替换为如下循环结构：1234567// abbreviated file-reading loop design// omit pre-loop inputwhile (inFiel &gt;&gt; value) //read and test for success&#123; //loop body goes here // cmit end-of-loop input&#125; 这种设计仍然遵循了在测试前进行读取的规则，因此要计算表达式inFile &gt;&gt; value的值，程序必须首先试图将一个数字读取到value中。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记：I/O写操作]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AI-O%E5%86%99%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[如下程序中，声明一个ofstream对象后，便可以使用方法open()将该对象特定文件关联起来：12ofstream outFile;outFile.open("carinfo.txt"); 程序使用完该文件后，应该将其关闭：1outFile.close(); 注意，方法close()不需要使用文件名作为参数，这是因为outFile已经同特定的文件关联起来。如果您忘记关闭文件，程序正常终止时将自动关闭它。outFile可以使用cout可使用的任何方法。他不但能够使用运算符&lt;&lt;，还可以使用各种格式化方法，如setf()和precision()。这些方法只影响调用它们的对象。例如，不同的对象，可以提供不同的值：12cout.precision(2); //use s precision of 2 for the displayoutFile.precision(4); //use a precision of 4 for file output 需要注意的重点是，创建好ofstream对象(如outFile)后，便可以像使用cout那样使用它。回到open()方法： outFile.open(“carinfo.txt”);在这里，程序运行之前，文件carinfo.txt并不存在。在这种情况下，方法open()将新建一个名为carinfo.txt的文件。如果在此运行该程序，文件carinfo.txt将生成，此情况将如何呢？默认情况下，open()将首先截断该文件，即将其长度截断到零————丢弃其原有的内容，然后将新的输出加到该文件中。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;fstream&gt;int main()&#123; using namespace std; char automobile[50]; int year; double a_price; double d_price; ofstream outFile; outFile.open("carinfo.txt"); cout&lt;&lt;"Enter the make and model of automobile:"; cin.getline(automobile, 50); cout&lt;&lt;"Enter the model year:"; cin&gt;&gt;year; cout&lt;&lt;"Enter the original asking price:"; cin&gt;&gt;a_price; d_price = 0.913 * a_price; cout&lt;&lt;fixed; cout.precision(2); cout.setf(ios_base::showpoint); cout&lt;&lt;"Make and model:"&lt;&lt;automobile&lt;&lt;endl; cout&lt;&lt;"year:"&lt;&lt;year&lt;&lt;endl; cout&lt;&lt;"Now asking $"&lt;&lt;d_price&lt;&lt;endl; outFile&lt;&lt;fixed; outFile.precision(2); outFile.setf(ios_base::showpoint); outFile&lt;&lt;"Make and model:"&lt;&lt;automobile&lt;&lt;endl; outFile&lt;&lt;"Year:"&lt;&lt;year&lt;&lt;endl; outFile&lt;&lt;"Was asking $"&lt;&lt;a_price&lt;&lt;endl; outFile&lt;&lt;"Now asking $"&lt;&lt;d_price&lt;&lt;endl; outFile.close(); return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记：cin.get()]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9Acin-get%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718#include &lt;iostream&gt;int main()&#123; using namespace std; char ch; int count = 0; cout &lt;&lt; "Enter character; enter # to quit:\n"; cin.get(ch); while (ch!='#') &#123; cout &lt;&lt; ch; ++count; cin.get(ch); &#125; cout &lt;&lt; endl &lt;&lt; cout &lt;&lt; "characters read\n"; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C-表白源码]]></title>
    <url>%2F2018%2F07%2F14%2FC-%E8%A1%A8%E7%99%BD%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[编译环境：VS2013及以上 源码下载密码：mqtd]]></content>
      <categories>
        <category>C语言编程</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记：调用约定]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1.C调用约定x86体系结构的许多C编译器使用默认调用约定叫做C调用约定。如果默认的调用约定被重写，则C/C++程序中常用的_cdecl修饰符会迫使编译器利用C调用约定。自现在开始，我们把这种调用约定叫做cdecl调用约定cdecl调用约定规定：调用方按从右到左的顺序将函数参数放入栈，在被调用的函数完成其操作时，调用方（而不是被调用方）负责从栈中清除参数。从右到左在栈中放入参数的一个结果是，如果函数被调用，最左边的（第一个）参数将始终位于栈顶。这样，无论该函数需要多少个参数，我们都可以轻易找到用第一个参数。因此，cdecl调用约定非常适用于那些参数数量可变的函数（如printf）。要求调用函数从栈中删除参数，意味着你将经常看到：指令在由被调用的函数返回后，会立刻对程序栈指针进行调整。如果函数能够接受数量可变的参数，则调用方非常适于进行这种调整，因为它清楚地知道，它向函数传递了多少个参数，因此能够轻松做出正确的调整。而被调用的函数无法提前知道自己会收到多少个参数，因此很难对栈做出必要的调整。在下面的例子中，我们调用一个拥有以下原型的函数：1void demo_cdecl(int w,int x,int y,int z); 默认情况下，这个函数将使用cdecl调用约定，并希望你按从右到左的顺序压人4个参数，同时要求调用方清除栈中的参数。编译器可能会为这个函数的调用生成以下代码：1234567;demo_cdecl(1,2,3,4); //programmer calls demo_cdecl① push 4 ;push parameter z push 3 ;push parameter y push 2 ;push parameter x push 1 ;push parameter w call demo_cdecl ;call the function② add esp,16 ;adjust esp to its former value 从①开始的4个push操作使程序栈指针（ESP）发生16个字节（在32位体系结构上为 4*sizeof (int)）的变化，从demo_cdecl返回后，它们在②处被撤销。如果demo_cdecl被调用50次，那么，每次被调用之后，都会发生类似于②处的调整。下面的例子同样遵照cdecl调用约定，但是，每次调用demo_cdecl后，调用方不需要删除栈中的参数。123456;demo_cdecl(1,2,3,4); //programmer calls demo_cdecl mov [esp+12],4 ;move parameter z to fourth position on stack mov [esp+8], 3 ;move parameter y to third position on stack mov [esp+4],2 ;move parameter x to second position on stack mov [esp],1 ;move parameter w to top of stack call demo_cdecl ;call the function 在这个例子中，在函数的“序言”阶段，编译器已经在栈顶为demo_cdecl的参数预先分配了存储空间。在demo_cdecl结束后，也就不需要调整栈指针。GNU编译器（gcc和g++）正是利用这种技巧将函数放到栈上的。注意，无论采用哪一种方法，在调用函数时，栈指针都会指向最左边的参数。 2.标准调用约定这里的“标准”似乎有些用词不当，因为它是微软自己的调用约定所起的名称。这种约定在函数声明时使用了修饰符_stdcall，如下所示：1void _stdcall demo_stdcall(int w,int x,int y); 为避免“标准”一词引起混淆，在本书的剩余部分，我们将这种调用约定称为stdcall调用约定。和cdecl调用约定一样，stdcall调用约定按从右到左的顺序将函数参数放在程序的栈上。使用stdcall调用约定的区别在于：函数结束执行时，应由被调用的函数负责删除栈中的函数参数。对被调用的函数而言，要完成这个任务，它必须清楚知道栈上有多少个参数，这只有在函数接受对的参数数量固定不变时才有可能。因此，printf这种接受数量可变的参数的函数不能使用stdcall调用约定。例如，demo_stdcall函数需要3个整数参数，在栈上共占用12个字节（在32位体系结构上为3*sizeof(int)）的空间。x86编译器能够使用RET指令的一种特殊形式，同时从栈顶提取返回地址，并给栈指针加上12，以消除函数参数。demo_stdcall可能会使用以下指令返回到调用方：1ret 12 ; return and claer 12 bytes from the stack 使用stdcall的主要优点在于，每次函数调用之后，不需要通过代码从栈中清除参数，因而能生成体积稍小、速度较快的程序。根据惯例，微软对所有由共享库（DLL）文件输出的参数数量固定的函数使用stdcall约定。如果你正尝试为某个共享库组件生成函数原型或二进制兼容的替代者，请记住这一点。 3.x86fastcall约定fastcall约定是stdcall约定的一个变体，它向CPU寄存器（而非程序栈）最多传递两个参数。Microsoft Visual C/C++ 和GNU gcc/g++（3.4及更低版本）编译器能够识别函数声明中的fastcall修饰符。如果指定使用fastcall约定，则传递给函数的前两个参数分别位于ECX和EDX寄存器中。剩余的其他参数则以类似于stdcall约定的方式从右到左放入栈上。同样与stdcall约定类似的是，在返回其调用方时，fastcall函数负责从栈中删除参数。下面的声明中即使用了fastcall修饰符：1void fastcall demo_fastcall (int w, int x, int y, int z); 为调用demo_stdcall，编译器可能会生成以下代码：123456; demo_fastcall(1,2,3,4); //programmer calls demo_fastcall push 4 ; move parameter z to second position on stack push 3 ; move parameter y to top position on stack mov edx, 2 ; move parameter x to edx mov ecs, 1 ; move parameter w to ecx call demo_fastcall ; call the function 注意，调用demo_fastcall返回后，并不需要调整栈，因为demo_fastcall负责在返回到调用方时从栈中清除参数y和z。由于有两个参数被传递到寄存器中，被调用的函数仅仅需要从栈中清除8个字节，即使该函数拥有4个参数，理解这一点很重要。 4.C++调用约定C++类中的非静态成员函数与标准函数不同，它们需要使用this指针，该指针指向用于调用函数的对象。用于调用函数的对象的地址必须由调用方提供，因此，它在调用非静态成员函数时作为参数提供。C++语言标准并未规定应如何向非静态成员函数传递指针，因此，不同编译器使用不同的技巧来传递指针，这一点也不足为奇了。Microsoft Visual C++提供thiscall调用约定，它将this指针传递给ECX寄存器中，并且和在stacall中一样，它要求非静态成员函数清除栈中的参数。GNU g++编译器将this看成是任何非静态成员函数的第一个隐含参数，而在所有其他方面与使用cdecl约定相同。因此，对使用g++编译的代码来说，在调用非静态成员函数之前，this被放置到扎拟定，且调用方负责在函数返回时删除栈中的参数（至少有一个参数）。 5.其他调用约定要完整地介绍现有的每一个调用约定，可能需要写一本书。调用约定通常是特定于语言、编译器和CPU的。如果遇到由更为少见的编译器生成的代码，可能需要你自己进行一番研究。但是，以下这些情况需要特别注意：优化代码、定制汇编语言代码和系统调用。如果输出函数（如库函数）是为了供其他程序使用，那么，它必须遵照主流的调用约定，以便程序员能够轻松调用。另一方面，如果函数仅供内部程序使用，则该函数需要采用只有函数的程序才了解的调用约定。在这类情况下，优化编译器会选择使用备用的调用约定，以生成运行速度更快的代码。这样的例子包括：在Microsoft Visual C++中使用/GL选项，以及在GNU gcc/g++中使用regparm关键字。如果程序员不怕麻烦，使用汇编语言，那么，他们就能够完全控制如何向他们创建的函数传递参数。除非他们希望创建供其他程序员使用的函数，否则，汇编语言程序员能够以任何他们认为恰当的方式传递参数。因此，在分析自定义汇编代码时，请格外小心。在模糊程序（obfuscation routine）和shellcode中经常可以看到自定义汇编代码。系统调用是一种特殊的函数调用，用于请求一项操作系统服务。通常，系统调用会造成状态转换，由用户模式进入内核模式，以便操作系统内核执行用户的请求。启动系统调用的方式因操作系统和CPU而异。例如，Linux x86系统调用使用int 0x80指令启动，而其他x86操作系统可能使用sysenter指令。在许多x86系统中（Linux是一个例外）上，系统调用的参数位于运行时栈上，并在启动系统调用之前，在EAX寄存器中放入一个系统调用编号。Linux系统调用接受位于特定寄存器中的参数，有时候，如果可用寄存器无法存储所有的参数，它也可以接受位于程序栈上的参数。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习笔记：栈帧]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%A0%88%E5%B8%A7%2F</url>
    <content type="text"><![CDATA[栈帧（stack frame）是这样一种低级概念。栈帧是在程序的运行时时栈中分配的内存块，专门用于特定的函数调用。程序员通常会将可执行语句分组，划分成叫做函数（也称过程、子例程或方法）的单元。有时候，这样做是按照所使用的语言的的要求。多数情况下，以这些函数单元为基础构建程序是一种良好的编程实践。如果一个函数并未执行，通常它并不需要内存。但是，但函数被调用时，它就可能因为某种原因需要用到内存。这源于几个方面的原因。其一，函数的调用方可能希望以参数的方式向该函数传递信息，这些参数需要存储在某个地方，以方便函数查找它们。其二，在执行任务的过程中，函数可能需要临时放入存储空间。程序员通常会通过声明局部变量来分配这类临时空间，这些变量将在函数执行过程中使用，但一旦完成函数调用，就无法再访问。编译器利用栈帧（也叫激活记录）对函数参数和局部变量进行分配和释放（整个过程对程序员透明）。将在控制权转交给函数之前，编译器会插入代码，将函数参数放入栈帧内，并分配足够的内存，以保存函数的局部变量。鉴于栈帧的结构，该函数的返回地址也存储子啊新的栈帧内。使用栈帧使得递归成为可能，因为每个递归函数调用都有他自己的栈帧，这恰好将当前调用与前一次调用分隔开来。下面是调用一个函数时的详细操作步骤。（1）调用方将被调用函数所需的任何参数放入到该函数所采用的的调用约定指定的位置。如果参数被放到运行时栈上，该操作可能导致程序的栈指针发生改变。（2）调用方将控制权转交给被调用的函数，这个过程由x86CALL或MIPS JAL等指令执行。然后，返回地址被保存到程序栈或CPU寄存器中。（3）如有必要，被调用的函数会配置一个栈指针，并保存调用方希望保持不变的任何寄存器值。（4）被调用的函数为它可能需要的任何局部变量分配内存空间。一般，通过调整程序栈指针在运行时上保留空间来完成这一任务。（5）被调用的函数执行其操作，可能生成一个结果。在执行操作的过程中，被调用的函数可能会访问调用函数传递给它的参数。如果函数返回一个结果，此结果通常被放置到一个特定的寄存器中，或者放置到函数返回后调用方可立即访问的寄存器中。（6）一旦函数完成其操作，任何为局部变量保存的栈空间即被释放。通常，逆向执行第（4）步中的操作，即可完成这个任务。（7）如果某个寄存器的值还为调用方保存（第（3）步）着，那么将其恢复到原始值。这包括恢复调用方的栈指针寄存器。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比较char与string]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%AF%94%E8%BE%83char%E4%B8%8Estring%2F</url>
    <content type="text"><![CDATA[使用C-风格字符串中的strcmp()函数来比较。该函数接受两个字符串地址作为参数。这意味这参数可以是指针、字符串常量或字符数组名。如果两个字符串相同。该函数返回0,；如果第一个字符串按字母排序排在第二个字符之后，则strcpm()将返回一个正数值。实际上，“按系统排序顺序”比“按字母顺序”更准确。这意味着字符是根据字符的系统编码来进行比较的。例如，使用ASCII码时，所有大写字母的编码都比小写字母小，所以按排序顺序，大写字母将位于小写字母之前。因此，字符串“Zoo”在字符串“ariary”之前。根据编码进行比较还意味着大写字母和小写字母是不同的，因此字符串“FOO”和字符串“foo”不同。在有些语言（入BASIC和标准Pascal）中，存储在不同长度的数组中的字符串彼此不相同。但是C-风格字符串是通过结尾的空值字符定义的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中，也可能是相同的： char big[80] = “Daffy”; //5 letters plus \0 char little[6] = “Daffy”; //5 letters plus \0顺便一说，虽然不能用关系运算符来比较字符串，但却可以用来比较字符，因为字符实际上是整型。因此下面的代码可以用来显示字母表中的字符，至少对于ASCII字符集和Unicode字符集来说是有效的：for(ch = ‘a’ ch &lt;+ ‘z’;ch++) cout &lt;&lt; ch;123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;int main()&#123; using namespace std; char word[5]="?ate"; for(char ch = 'a';strcmp(word,"mate");ch++) &#123; cout &lt;&lt; word &lt;&lt; endl; word[0]=ch; &#125; cout &lt;&lt; "After loop ends,word is "&lt;&lt;word&lt;&lt;endl; return 0;&#125; 检测相等或排列顺序：可以使用strcmp()来测试C-风格字符串是否相等（排列顺序）。如果str1和str2相等，则下面的表达式为true：strcmp(str1,str2) == 0如果str1和str2不相等，则下面两个表达式都为true：strcmp(str1,str2) != 0strcmp(str1,str2)如果str1在str2前面，则下面的表达式为true：strcmp(str1,str2) &lt; 0如果str1在str2后面，则下面的表达式为true：strcmp(str1,str2) &gt; 01234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; using namespace std; string word="?ate"; for (char ch = 'a';word!="mate";ch++) &#123; cout &lt;&lt; word &lt;&lt;endl; word[0]=ch; &#125; cout &lt;&lt; "After loop ends,word is "&lt;&lt;word&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习笔记:C++primer.plus编程练习题答案]]></title>
    <url>%2F2018%2F07%2F10%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-C-primer-plus%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[第四章 5.结构CandyBar包含3个成员。第一个成员储存了糖块的品牌；第二个成员储存糖块的重量（可以有小数）；第三个成员储存了糖块的卡路里含量（整数）。请编写一个程序，声明这个结构，创建一个名为snack的CandyBar变量，并将其成员分别初始化为“Mocha Munch”、2.3和350.初始化应用在声明snack时进行。最后，程序显示snack变量的内容。123456789101112131415161718192021#include &lt;iostream&gt;const int Asize=20;struct CandyBar&#123; char brand[Asize]; double weight; int calory;&#125;;int main()&#123; using namespace std; CandyBar snack=&#123;"Mocha Munch",2.3,350&#125;; cout&lt;&lt;"Here's the information of snack:\n"; cout&lt;&lt;"brand:"&lt;&lt;snack.brand&lt;&lt;endl; cout&lt;&lt;"weight:"&lt;&lt;snack.weight&lt;&lt;endl; cout&lt;&lt;"calory:"&lt;&lt;snack.calory&lt;&lt;endl; return 0;&#125; 6.结构CandyBar包含3个成员，如编程练习5所示。请编写一个程序，创建一个包含3个元素的CandyBar数组，并将它们初始化为所选择的值，然后显示每个结构的内容。12345678910111213141516171819202122232425#include &lt;iostream&gt;const int Asize=20;struct CandyBar&#123; char brand[Asize]; double weight; int calory;&#125;;int main()&#123; using namespace std; CandyBar snack[3]=&#123; &#123;"Moucha Munch",2.3,350&#125;, &#123;"XuFuji",1.1,300&#125;, &#123;"Alps",0.4,100&#125; &#125;;for(int i=0;i&lt;3;i++) &#123; cout&lt;&lt;snack[i].brand&lt;&lt;endl &lt;&lt;snack[i].weight&lt;&lt;endl &lt;&lt;snack[i].calory&lt;&lt;endl&lt;&lt;endl; &#125; return 0;&#125; 7.William Wingate从事披萨饼分析服务。对于每个披萨饼，他都需要记录下列信息： 披萨饼公司的名称，可以有多个单词组成。 披萨饼的直径。 披萨饼的重量。请设计一个能够存储这些信息的结构，并编写一个使用这种结构的程序。程序将请求用户输入上述信息，然后显示这些信息。请使用cin（或它的方法）和cout。1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;const int Size=20;struct pizza//声明结构&#123; char company[Size]; double diameter; double weight;&#125;;int main()&#123; using namespace std; pizza pie;//创建一个名为pie的结构变量 cout&lt;&lt;"What's the name of pizza company:"; cin.getline(pie.company,Size); cout&lt;&lt;"What's the diameter of pizza:"; cin&gt;&gt;pie.diameter; cout&lt;&lt;"What's the weight of pizza:"; cin&gt;&gt;pie.weight; cout&lt;&lt;"company:"&lt;&lt;pie.company&lt;&lt;endl; cout&lt;&lt;"diameter:"&lt;&lt;pie.diameter&lt;&lt;"inches"&lt;&lt;endl; cout&lt;&lt;"weight:"&lt;&lt;pie.weight&lt;&lt;"ounches"&lt;&lt;endl; return 0;&#125; 第六章3.编写一个菜单驱动程序的雏形。该程序显示提供4个选项的菜单————每个选项用一个字母标记。如果用户使用有效选项之外的字母进行响应，程序将提示用户输入一个有效的字母，直到用户这样做为止。然后，该程序使用一条swich语句，根据用户的执行一个简单的操作。该程序的运行情况如下： Please enter one of the following choices: c) carnivore p) pianist t) tree g) game f Please enter a c,p,t, or g:q Please enter a c,p,t, or g:t A maple is a tree 源代码如下：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cctype&gt;int main()&#123; using namespace std; cout &lt;&lt; "Please enter one of the following choices:\n" &lt;&lt; "c)carnivore p)pianist\n" &lt;&lt; "t)tree g)game\n"; cout &lt;&lt; "Please enter a c,p,t, or g:"; char ch; cin&gt;&gt;ch; while(ch!='c'&amp;&amp;ch!='p'&amp;&amp;ch!='t'&amp;&amp;ch!='g') &#123; cout&lt;&lt;"Please enter a c,p,t, or g:"; cin&gt;&gt;ch; &#125; switch(ch) &#123; case 'c': cout&lt;&lt;"A maple is a carnivore.\n"; break; case 'p': cout&lt;&lt;"A maple is a painist.\n"; break; case't': cout&lt;&lt;"A maple is a tree.\n"; break; case 'g': cout&lt;&lt;"A maple is a game.\n"; &#125; return 0;&#125; 在Ncutronia王国，货币单位是tvarp，收入所得税的计算方式如下：5000 tvarps: 不收税5001~15000 tvarps: 10%15001~35000 tvarps: 15%35000 tvarps以上：20%例如，收入在38000tvarps时，所得税为5000 x 0.00 + 10000 x 0.10 + 20000 x 0.15 + 3000 x 0.20,即4600 tvarps。请编写一个程序，使用循环来要求用户输入收入，并报告所得税。当用户输入负数或非数字时，循环将结束。123456789101112131415161718192021222324#include &lt;iostream&gt;int main()&#123; using namespace std; double income,revenue; cout&lt;&lt;"请输入你的收入："; while(cin&gt;&gt;income&amp;&amp;income&gt;=0) &#123; if(income&lt;=5000) revenue=0.0; else if(income&lt;=15000) revenue=0.1*(income-5000); else if(income&lt;=35000) revenue=0.1*(15000-5000)+0.15*(income-15000); else revenue=0.1*(15000-5000)+0.15*(35000-15000)+0.2*(income-35000); cout&lt;&lt;"你的所得税为："&lt;&lt;revenue&lt;&lt;endl; cout&lt;&lt;"请输入你的收入："; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[32位汇编寄存器(转载)]]></title>
    <url>%2F2018%2F07%2F02%2F32%E4%BD%8D%E6%B1%87%E7%BC%96%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[32位CPU所含有的寄存器有： 4个数据寄存器(EAX、EBX、ECX和EDX)2个变址和指针寄存器(ESI和EDI) 2个指针寄存器(ESP和EBP)6个段寄存器(ES、CS、SS、DS、FS和GS)1个指令指针寄存器(EIP) 1个标志寄存器(EFlags) 1、数据寄存器数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。 32位CPU有4个32位的通用寄存器EAX、EBX、ECX和EDX。对低16位数据的存取，不会影响高16位的数据。这些低16位寄存器分别命名为：AX、BX、CX和DX，它和先前的CPU中的寄存器相一致。 4个16位寄存器又可分割成8个独立的8位寄存器(AX：AH-AL、BX：BH-BL、CX：CH-CL、DX：DH-DL)，每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可分可合”的特性，灵活地处理字/字节的信息。 寄存器AX和AL通常称为累加器(Accumulator)，用累加器进行的操作可能需要更少时间。累加器可用于乘、除、输入/输出等操作，它们的使用频率很高；寄存器BX称为基地址寄存器(Base Register)。它可作为存储器指针来使用；寄存器CX称为计数寄存器(Count Register)。在循环和字符串操作时，要用它来控制循环次数；在位操作中，当移多位时，要用CL来指明移位的位数；寄存器DX称为数据寄存器(Data Register)。在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址。 在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。 2、变址寄存器32位CPU有2个32位通用寄存器ESI和EDI。其低16位对应先前CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。 寄存器ESI、EDI、SI和DI称为变址寄存器(Index Register)，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 变址寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。 它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。 3、指针寄存器32位CPU有2个32位通用寄存器EBP和ESP。其低16位对应先前CPU中的SBP和SP，对低16位数据的存取，不影响高16位的数据。 寄存器EBP、ESP、BP和SP称为指针寄存器(Pointer Register)，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。 指针寄存器不可分割成8位寄存器。作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。 它们主要用于访问堆栈内的存储单元，并且规定： BP为基指针(Base Pointer)寄存器，用它可直接存取堆栈中的数据；SP为堆栈指针(Stack Pointer)寄存器，用它只可访问栈顶。 4、段寄存器段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。 CPU内部的段寄存器：123456CS——代码段寄存器(Code Segment Register)，其值为代码段的段值；DS——数据段寄存器(Data Segment Register)，其值为数据段的段值；ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值；FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值；GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。 在16位CPU系统中，它只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问；在32位微机系统中，它有6个段寄存器，所以，在此环境下开发的程序最多可同时访问6个段。 32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的。有关规定简单描述如下： 实方式： 前4个段寄存器CS、DS、ES和SS与先前CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为“段值：偏移量”的形式。为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移量。 保护方式： 在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”(Selector)的某个值。 5、指令指针寄存器32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前CPU中的IP作用相同。 指令指针EIP、IP(Instruction Pointer)是存放下次将要执行的指令在代码段的偏移量。在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况。所以，在理解它们的功能时，不考虑存在指令队列的情况。 在实方式下，由于每个段的最大范围为64K，所以，EIP中的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中指令的执行次序。 6、标志寄存器一、运算结果标志位1、进位标志CF(Carry Flag)进位标志CF主要用来反映运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 使用该标志位的情况有：多字(字节)数的加减运算，无符号数的大小比较运算，移位操作，字(字节)之间移位，专门改变CF值的指令等。 2、奇偶标志PF(Parity Flag)奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 利用PF可进行奇偶校验检查，或产生奇偶校验位。在数据传送过程中，为了提供传送的可靠性，如果采用奇偶校验的方法，就可使用该标志位。 3、辅助进位标志AF(Auxiliary Carry Flag)在发生下列情况时，辅助进位标志AF的值被置为1，否则其值为0： (1)、在字操作时，发生低字节向高字节进位或借位时；(2)、在字节操作时，发生低4位向高4位进位或借位时。 对以上6个运算结果标志位，在一般编程情况下，标志位CF、ZF、SF和OF的使用频率较高，而标志位PF和AF的使用频率较低。 4、零标志ZF(Zero Flag)零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。 5、符号标志SF(Sign Flag)符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。 6、溢出标志OF(Overflow Flag)溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 “溢出”和“进位”是两个不同含义的概念，不要混淆。如果不太清楚的话，请查阅《计算机组成原理》课程中的有关章节。 二、状态控制标志位状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。 1、追踪标志TF(Trap Flag)当追踪标志TF被置为1时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。 指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其它办法来改变其值。 2、中断允许标志IF(Interrupt-enable Flag)中断允许标志IF是用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下： (1)、当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求； (2)、当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。 CPU的指令系统中也有专门的指令来改变标志位IF的值。 3、方向标志DF(Direction Flag)方向标志DF用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第5.2.11节——字符串操作指令——中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF的值。 三、32位标志寄存器增加的标志位1、I/O特权标志IOPL(I/O Privilege Level)I/O特权标志用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。 2、嵌套任务标志NT(Nested Task)嵌套任务标志NT用来控制中断返回指令IRET的执行。具体规定如下： (1)、当NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的中断返回操作； (2)、当NT=1，通过任务转换实现中断返回。 3、重启动标志RF(Restart Flag)重启动标志RF用来控制是否接受调试故障。规定：RF=0时，表示“接受”调试故障，否则拒绝之。在成功执行完一条指令后，处理机把RF置为0，当接受到一个非调试故障时，处理机就把它置为1，中国自学编程网整理发布！。 4、虚拟8086方式标志VM(Virtual 8086 Mode)如果该标志的值为1，则表示处理机处于虚拟的8086方式下的工作状态，否则，处理机处于一般保护方式下的工作状态。]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮点数的编码方式]]></title>
    <url>%2F2018%2F07%2F02%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.float类型的IEEE编码在进行二进制转换前，需要对单精度浮点数进行科学计数法。例如，将float类型的12.25f转换成IEEE编码，需要12.25f转换成对应的二进制数1100.01，整数部分为1100，小数部分为01；小数点向左移动，每移动1次指数加1，移动到除符号位的最高位为1处，停止移动,这里移动3次。对12.25f进行科学计数法转换后二进制部分为1.10001，指数部分为3.在IEEE编码中，由于在二进制情况下最高位始终为1，为一个恒定值，故将其忽略不计。这里是一个整数，所以符号位添0。 12.25经转换后各位的情况： 符号位：0 指数位：十进制3+127，转换为二进制是10000010 尾数位：10001000000000000000000由于尾数位中最高位为1是恒定值，故省略不计，只要转换回十进制时加1即可。为什么指数位要加127呢？由于指数可能出现负数，十进制数127可表示二进制数01111111.IEEE编码方式规定，当指数域小于01111111时为一个负数，反之为正数，因此01111111为0。12.25f转换后的IEEE编码按照二进制拼接为01000001010001000000000000000000。转换成十六进制数为0x41440000，内存中以小尾方式排列，故为00 00 44 41。分析结果如下图所示：上面演示了符号位为正，指数位也为正的情况。那么什么情况下指数为负呢？根据科学计数法，小数点向小数部分移动时，指数需要以0开始做减法。浮点数-0.125f转换为IEEE编码后，将会是一个符号位为1，指数部分为负的小数。-0.125f经转换后二进制部分为0.001，用科学计数法表示为1.0；指数部分为-3.-0.125fIEEE转换后各位的情况： 符号位：1 指数位：十进制127+(-3)，转换为二进制是01111100，如果不足为8位，则高位补0 尾数位：00000000000000000000000-0.125f转换后的IEEE编码二进制拼接为10111110000000000000000000000000。转换成十六进制为0xBE000000，内存中显示为00 00 00 BE上面的两个浮点数小数部分转换为二进制时都是有穷的，如果小数部分转换为二进制时得到一个无穷值，则会根据尾数部分的长度舍弃多余的部分。单精度数1.3f，小数部分转换为二进制就会产生无穷值，依次转换为：0.3、0.6、1.2、0.4、0.8、1.6、0.4、0.8…转换后得到的二进制数为1.01001100110011001100110，到23位终止，尾数部分无法保存更大的值。1.3f经IEEE转换后各位的情况： 符号位：0 指数位：十进制0+127，转换二进制01111111 尾数位：010011001100110011001101.3f转换后的IEEE编码二进制拼接为00111111101001100110011001100110。转换成十六进制为0x3FA66666，内存中显示为66 66 A6 3F。由于在转换二进制过程中产生了无穷值，舍弃了部分位数，所以进行IEEE编码转换得到的是一个近似值，存在一定误差。再次将这个IEEE编码转换成十进制小数，得到的值为1.2516582，四舍五入后为1.3。这就解释了为什么C++在比较浮点数值是否为0时，要做一个区间比较而不是直接进行等值比较。正确浮点数比较的代码如下图所示：12345float fTemp = 0.0001f;if (fFloat &gt;= -fTemp &amp;&amp; fFloat &lt;= fTemp)&#123;//fTemp等于0&#125; 2.double类型的IEEE编码double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。double类型占8字节的内存空间，同样，高位也用于表示符号，指数位占11位，剩余42位用于表示位数。在float中，指数范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，加1023后可用于指数符号判断。double类型的IEEE编码转换过程与float类型一样，可根据float类型的转换流程来转换double类型。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2.2.2基于UDP的通信]]></title>
    <url>%2F2018%2F07%2F02%2F2-2-2%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1.服务器端代码基于UDP协议的服务器端程序不会去监听端口和等待请求连接，因此UDP协议的服务器端程序相对于TCP协议的服务器程序来说代码更短。基于UDP协议的服务器端代码如下：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, "ws2_32")int main()&#123; WSADATA wsaData; WSAStartup(MAKEWORD (2, 2), &amp;wsaData); //创建套接字 SOCKET sServer = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); //对sockaddr_in结构体填充地址、端口等信息 struct sockaddr_in ServerAddr; ServerAddr.sin_family = AF_INET; ServerAddr.sin_addr.S_un.S_addr = inet_addr("10.10.30.16"); ServerAddr.sin_port = htons(1234); //绑定套接字与地址信息 bind(sServer, (SOCKADDR *)&amp;ServerAddr, sizeof(ServerAddr)); //接收消息 char szMsg[MAXBYTE] = &#123;0&#125;; struct sockaddr_in ClientAddr; int nSize = sizeof(ClientAddr); recvfrom(sServer, szMsg, MAXBYTE, 0, (SOCKADDR*)&amp;ClientAddr,&amp;nSize); printf("Client Msg:%s \r\n",szMsg); printf("ClientIP=%s:%d\r\n",inet_ntoa(ClientAddr.sin_addr),ntohs(ClientAddr.sin_port)); //发送消息 lstrcpy(szMsg, "Hello Client!\r\n"); nSize = sizeof(ClientAddr); sendto(sServer,szMsg,strlen(szMsg) + sizeof(char),0,(SOCKADDR*)&amp;ClientAddr,nSize); WSACleanup(); return 0;&#125; 2.客户端代码基于UDP客户端的代码相对于TCP协议的客户端来讲，不需要调用connect()函数进行连接，省去了TCP协议的“三次握手”的过程，可以直接发送数据给服务器。基于UDP协议的客户端代码如下：123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, "ws2_32")int main()&#123; WSADATA wsaData; WSAStartup(MAKEWORD (2, 2), &amp;wsaData); //创建套接字 SOCKET sClient = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); //对sockaddr_in结构体填充地址、端口等信息 struct sockaddr_in ServerAddr; ServerAddr.sin_family = AF_INET; ServerAddr.sin_addr.S_un.S_addr = inet_addr("10.10.30.16"); ServerAddr.sin_port = htons(1234); //发送消息 char szMsg[MAXBYTE] = &#123;0&#125;; lstrcpy(szMsg, "Hello Server!\r\n"); int nSize = sizeof(ServerAddr); sendto(sClient,szMsg,strlen(szMsg) + sizeof(char),0,(SOCKADDR*)&amp;ServerAddr,nSize); //接受消息 nSize = sizeof(ServerAddr); recvfrom(sClient, szMsg, MAXBYTE, 0, (SOCKADDR*)&amp;ServerAddr,&amp;nSize); printf("Server Msg: %s \r\n",szMsg); WSACleanup(); return 0;&#125; 完成服务器端和客户端代码后，将代码都进行编译连接，然后先运行服务器端的程序，再运行客户端程序，这时可以看到服务器端和客户端能够正常接收到对方发来的字符串信息，说明通信成功。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.1实例;基于TCP的通信]]></title>
    <url>%2F2018%2F07%2F02%2F2-2-1%E5%AE%9E%E4%BE%8B-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1.服务器端代码创建一个TCP的服务器端的程序需要调用的函数流程如下：1WSAStartup()-&gt;socket()-&gt;bind()-&gt;listen()-&gt;accept()-&gt;send()/recv()-&gt;closesocket()-&gt;WSACleanup() 只要依次调用上面的函数即可。服务器端的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, "ws2_32")int main()&#123; WSADATA wsaData; WSAStartup(MAKEWORD(2, 2),&amp;wsaData); //创建套接字 SOCKET sListen = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //对sockaddr_in结构体填充地址、端口信息 struct sockaddr_in ServerAddr; ServerAddr.sin_family = AF_INET; ServerAddr.sin_addr.S_un.S_addr = inet_addr("10.10.30.16"); ServerAddr.sin_port = htons(1234); //绑定套接字与地址信息 bind(sListen, (SOCKADDR *)&amp;ServerAddr, sizeof(ServerAddr)); //端口监听 listen(sListen, SOMAXCONN); //获取连接请求 sockaddr_in ClientAddr; int nSize = sizeof(ClientAddr); SOCKET sClient = accept(sListen, (SOCKADDR *)&amp;ClientAddr, &amp;nSize ); //输出客户端使用的IP地址和端口号 printf("ClientIP=%s:%d\r\n",inet_ntoa(ClientAddr.sin_addr),ntohs(ClientAddr.sin_port)); //发送消息 char szMsg[MAXBYTE] = &#123;0&#125;; lstrcpy(szMsg, "hello Client!\r\n"); send(sClient, szMsg,strlen(szMsg) + sizeof(char), 0 ); //接收消息 recv(sClient, szMsg,MAXBYTE, 0); printf("Client Msg : %s \r\n",szMsg); WSACleanup(); return 0;&#125; 这样一个服务器端的程序就完成了。为了起到演示的作用，不让多余的东西影响流程的清晰化，这里没有对API函数的返回值进行判断。在实际的开发中，为了保证程序的健壮性，应该对各函数的返回值进行判断。 在一个工作区下再新建一个项目的过程PS：需要一定VC的基础，否则很可能会失败！ 2.客户端代码在客户端中同样也是调用前面介绍的API函数进行搭积木式的编程就可以了。客户端的代码调用API的流程如下：1WSAStartup()-&gt;socket()-&gt;connect()-&gt;send()/recv()-&gt;closexocket()-&gt;WSACleanup() 客户端的代码如下：1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#pragma comment (lib, "ws2_32")int main()&#123; WSADATA wsaData; WSAStartup(MAKEWORD(2, 2),&amp;wsaData); //创建套接字 SOCKET sServer = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //对sockaddr_in结构体填充地址、端口信息 struct sockaddr_in ServerAddr; ServerAddr.sin_family = AF_INET; ServerAddr.sin_addr.S_un.S_addr = inet_addr("10.10.30.16"); ServerAddr.sin_port = htons(1234); //连接服务器 connect(sServer, (SOCKADDR *)&amp;ServerAddr, sizeof(ServerAddr)); char szMsg[MAXBYTE] = &#123;0&#125;; //接收消息 recv(sServer, szMsg, MAXBYTE, 0); printf("Server Msg : %s \r\n", szMsg); //发送消息 lstrcpy(szMsg, "hello Server!\r\n"); send(sServer, szMsg,strlen(szMsg) + sizeof(char), 0); WSACleanup(); return 0;&#125; 效果如下所示：]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Winsock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲区溢出练习]]></title>
    <url>%2F2018%2F07%2F01%2Fauth-overflow%2F</url>
    <content type="text"><![CDATA[缓冲区溢出漏洞从计算机出现初期就已经存在，并且今天仍然存在。尽管C语言的简单性增加了程序员的控制能力，提高了最后得到的程序的效率，但是程序员不小心的话，这种简单性会导致程序缓冲区溢出和存储器泄露这样的漏洞。这意味着一旦给某个变量分配了内存空间，则没有内置的安全机制来确保这个变量的容量能适应已分配的存储空间。如果程序员把10个字节的数据存入只分配了8个字节空间的缓冲区中，这种操作是允许的，即使这种操作很可能导致程序崩溃。这称为缓冲区超限(buffer overrun)或缓冲区溢出，由于多出的2个字节数据会溢出，存储在已分配的存储空间之外，因此会重写已分配存储空间之后的数据。如果重写的是一段关键数据，程序会崩溃。通过破坏内存来控制执行流程。程序auth_overflow.c演示了这个概念。123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int check_authentication(char *password)&#123;int auth_flag = 0;char password_buffer[16];strcpy(password_buffer,password);if(strcmp(password_buffer,"brillig")==0) auth_flag = 1;if(strcmp(password_buffer,"outgrabe")==0) auth_flag = 1; return auth_flag;&#125;int main(int argc,char *argv[])&#123; if(argc&lt;2) &#123; printf("Usage:%s&lt;password&gt;\n",argv[0]); exit(0); &#125; if(check_authentication(argv[1])) &#123; printf("\n-=-=-=-=-=-=-=-=\n"); printf("Access Granted.\n"); printf("\n-=-=-=-=-=-=-=-=\n"); &#125;else&#123; printf("\nAccess Denied.\n"); &#125;&#125; 这个示例程序接受一个密码作为它唯一的命令行参数，然后调用函数check_authentication()。这个函数允许两个密码，意味着它允许多重验证方法。如果使用网络两个密码中的一个，函数会返回1，这样会授予访问权限。在编译代码前，通过查看源代码，您应该能够推测出它的大部分功能。但在程序时，请使用-g选项，因为随后会对其进行调试。您也许早就推测出会发生什么，但让我们使用调试工具对它进行检查以查看其细节。使用-q选项会使得GDB调试工具取消欢迎标语，并在第10行和第17行设置了断点。程序运行时，会在断点处暂停并为我们提供一个检查内存的机会。第1个断点在strcpy()发生之前。通过检查password——buffer指针，调试工具显示它填充的是随机的未初始化的数据，位于内存中0xbffff5ec处。通过检查auth_flag变量的地址，我们可以看到他的存储位置0xbffff5fc和它的值0。可以使用打印命令做算术运算，它显示auth_flag位于password_buffer开始之后的16字节处。也可以在以password_buffer开始的一块内存中看到这种关系。继续运行到strcpy()之后的第2个断点，再次对这些存储单元进行检查。password_buffer溢出到auth_flag中，将它的前两个字节变为0x41。值0x00004141可能看起来是颠倒的，但是要记住x86采用的是小端存储方式。如果单独检查每个4字节单元，就可以看到内存实际上是如何排列的。最终，程序会将这个值看做一个整数，其值为1094795585。溢出之后，函数check_authentication()会返回1094795585，而不是0.因为if语句认为任何非0值都能通过验证，所以程序执行流程进入授权部分。在这个列子中，变量auth_flag是执行控制点，因此覆盖该值是实现控制的根源。]]></content>
      <categories>
        <category>溢出</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一位程序员的十年总结(转载)]]></title>
    <url>%2F2018%2F07%2F01%2F%E4%B8%80%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%8D%81%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告走过的路，回忆起来是那么曲折，把自己的一些心得体会分享给程序员兄弟姐妹们，虽然时代在变化，但是很可能你也会走我已经做过的10年的路程，有些心得体会你可以借鉴一下，觉得说得有道理的你就接纳，觉得说得没道理的，你就抛弃，以下是我发自内心的，给大家的忠告，特别是针对那些小弟弟妹妹们。 01. 自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。由于程序员行业每年跳槽一次，我不隐瞒大家，我至少换过5个以上的单位，这期间跳来跳去，甚至是城市都换过3个。还好户口没丢掉，其他都已经是乱了，好几个城市里，都有交过三金，甚至是一个城市的2个区里交的都有，那些东西，10年后，会变得很重要。你买房子若有公积金，可以取出来，贷款利率也会比较低一些，有孩子了，还需要上学，生病了还需要医疗保险。特别是买房子时，你要商业贷款与公积金贷款的利率差别还是很大，有可能会有10万的差距。你平时都注意这些，会给你带来的损失会最小，例如每个月缴纳300元的公积金，公司也缴纳300元，你一个月能存下来600元，一年就是7200元，10年就是72000元。我以前都忽视了这些，到我需要买房子时，公积金里可能只有几千元，10年很快就过去了，结果我没能存下来多少公积金，医疗保险，养老金等更别提了，都已经稀里糊涂了，这些损失10年累加起来，是很庞大的数字，大家要注意，跳槽换工作时也要保护好自身的利益，现在房价很贵，你可能是跟我一样，大山里出来打拼的娃子，家里也没有丰厚的积蓄，只有靠自己拼搏，买房子是人生的一件大事，等你到了10年，才想到这个事情，已经晚了，特别是孩子要上学，上幼儿园等，需要户口啥的都要齐全。 02. 不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。这方面我的经验教训也是惨痛的。我大概前后购买过5-6个笔记本，以前的都是1万多元一台，最近买的是一台是1万多给女朋友的，自己买了一台是7500元左右，手机大概换过接近10个了，这些钱加起来也足够有10万以上了，你可能一不小心就购买了这些电子产品，但是时间长了，你一回过头来想想，你为什么赚得也不少，但是为什么还是那么穷，是因为你购买这些电子产品花费了过多的金钱了，平时笔记本啥的贵重物品要保护好，我一个同事不小心丢了2台笔记本电脑，接近2万的损失啊，你净赚2万，不是那么容易的，这个窟窿不是开玩笑的，我曾经也被人偷了一个崭新的笔记本，损失1.5万左右，更糟糕的是最新的代码也丢被偷了。 03. 这年代外语、学历、职称、驾驶证还是蛮重要的。想找高薪，外资企业是正确的选择，在同样的打工里，外资企业的收入普遍是高的，我就想不明白，我们的赚钱能力怎么就比不过人家了，社会不断发展，将来可能去外国就像串门一样了，也说不定的，外语好将来的就业机会也会更多更广一些。学历并不代表啥，但是学历也是敲门砖，例如有300个应聘者，那至少重点本科以下的，统统不看了，因为实在是来不及看了，你再厉害也被挡在机会的门外了，同样有时候你想改行什么的，职称也很重要，最起码评个中级职称，说不定还有机会能进入大学或者政府部门还是有可能性。若有充裕的时间，应该把驾驶证考了，因为你越到后面越忙与工作家庭，没机会学车了也说不定的，平时也别光顾拼命工作，工作10年后你才发现，原来身边的人都至少硕士学历了，你被社会自动淘汰了，我现在就有这个感觉，虽然我带过很多硕士，他们的就业机会比我还好，经常能进入名牌企业，我也一直进不去。 04. 不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。我谈过2个女朋友，平均每个女朋友身上的开支前后大概会有10万左右，还好我不用谈第3个女朋友了，若投资失误，那也是很残忍的，谈女朋友也会消耗很多时间精力、还会消耗很多金钱，实话的讲的确是这样的，人家女孩子也值钱啊，凭什么就那么轻易的跟你啊，我跟第一个朋友分手时，我的生活至少是倒退了3-4年，一切从零开始，一切从头开始，我劝大家谈女朋友是人生最大的一笔买卖，投资失误会有惨痛的后果，不仅仅是金钱上的损失，更会有精神、心灵上的沉重打击，大家要学会珍惜女朋友，要学会哄好女朋友，让老婆开心每一天，虽然鱼儿上钩了，不用再下鱼饵了，偶尔也别忘记放点米，这个鱼要是脱钩了，那不是开玩笑的。 05. 工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。换工作，换行业方向，就像熊掰苞米一样的道理，有时候是丢了芝麻捡西瓜，有时候是丢了西瓜捡芝麻，这个道理我就不多讲了，大家都应该能明白的。 06. 要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。有个朋友的QQ名字很有意思，“只爱陌生人”，陌生人是很有意思，但是最关键时刻，还是需要靠非陌生人，你每天跟同事一起生活，要维系好身边的人。你的成功与失败，往往是你身边的30-40个人决定的。你就是世界首富，他身边也是那么不超过100个人的在左右着他的生活，当你工作10年了，没一个老板信任你，没几个要好的同事朋友，那你惨了，你在这个世界上已经是很孤单了，你的收入，其实大多是来自这些身边的朋友给你介绍的生意，不大会网上掉几个馅饼的。现在你身边的人有可能在不久的将来，给你提供很多好机会。 07. 钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。钱不是万能的，但是没钱是万万不能的。钱赚了，身体夸了，全送给医院了，钱赚了，身心疲惫了，人活着为了啥？不就为了开开心心生活嘛？工作重要，但是失去了家人的爱，失去了女朋友，失去了老婆孩子，那这个工作有啥用了？工作很容易就换了，家人是换不了的，老婆不是想换就换的，孩子不是想换就换的，连自己的家庭都不负责的人，怎么可能对公司负责呢？我一直是这个观念，来面试时觉得工作更重要的，我们一般不录取的，那太假了，或者太不懂事了。 08. 工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。时间一晃就过去了，工作累了是可以适当放松，但是别太贪玩，10年很容易就过去了，10年后你要买房子，要娶老婆，要买车子，要生娃娃，身体也会变得脆弱一些，需要良好的生活习惯，也经不起通宵了，通宵一次，你要低迷好几天才能缓过劲儿来，跟20刚出头完全不一样了，用钱的地方多了去了，父母也会变得更老一些，可能也需要你的照顾，整个家子都指望你赚钱，别到了这个时候，你才意识到赚钱是那么的重要，更何况现在城市的房价，动不动就是100万，加上按揭的利息，你很可能需要支付150万。还可能需要装修，买车子。可能你身上的压力是200万。别觉得谈钱就俗，你要学会赚钱，要有个需要赚钱的良好意识，当然你出身富裕家庭，就不用考虑这些因素了。 09. 每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。总有一天，你也会有累的时候，你也会有老的时候，这时候，你要靠啥呢？就要靠你平时的积累，你10年的积累，可以打倒很多竞争对手，他们再厉害，再怎么样，也很难抵得过你10年的积累，特别是后面5-10年的积累，成果会很明显，前面的1-5年，算是做软件的入门吧，除非你有高人指点，那可能2-3年就可以修成正果，软件在将来还是会值钱的，以为生活会越来越智能化，越来越数字化，软件的需求还是很有前途，最起码未来的10-20年里不用太担心失业问题了。 10. 对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。我大概7-8年前的代码都在手上，经常改进来改进去，维护来维护去，在一定的程度上，让我生活轻松了不少，因为我不用什么都从头来过，我只要痛苦一次，以后就要反复重复利用，软件的价值在于重复利用，而不是每个东西，都从头开发，那永远也是辛苦的程序员，这个生活质量就别提了，不管自己的代码丑还是拿不出手，要学会精心维护，每天改进一点点，每个月一个小进步，每年一个大进步，多年的积累是宝贵的，这个早晚也会给你带来丰厚的收益。 11. 当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。我有一个朋友跟我开玩笑，工作5年的人，可能能力差距会很大，为什么呢？因为第一年他们干的事情都是一样的，都写程序了，2个人可能由于价值观不一样，5年后差距会很大，甚至是大到无法追赶的程度，为啥？因为还有机会的因素在里面，有的人干了5年，还是在原地踏步，天天只会写那些添加、删除、修改的代码。那你得注意了，需要不断的提高自己，才是硬道理。例如你会SQLServer，那要试着学习Oracle， 你是做C/S的，那得需要提高到B/S的，你是做单机软件的，那得需要提高到网络软件，你只关注自己的工作的，需要学会管理，关心他人的工作。你是当程序员的，要试着提高当项目经理、部门经理，公司的总监等等，人有野心有目标才会不断进步，最俗的为了多赚钱，提高工作职位工作岗位，工作单位，也是可以理解的。年纪越大工作越难找，例如3-4千的工作是随便找找，玩一样，但是你30过后，最起码要找月薪上1万的工作，这样的工作是机会也少，一般小公司也给不起，还得找个好公司才可以，好公司又不是天天招聘人，天天缺好的工作岗位，说不好听点儿，小公司的老板才赚多少啊？他来钱也很不容易的，小池塘就不好容得下大鲨鱼了。 12.当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。创业的收入，比打工还少，那就是瞎扯蛋，恶搞。创业的真正意思并不是要你去吃苦没钱赚，那是忽悠无知的人的。当你创业时的收入，比打工还多，那你可以考虑创业，没有工资什么的，股份啥的，都是瞎扯蛋。不要跟自己能力还弱的人一起创业，那损失最大的，很可能就是你，要创业，也要找比自己强的人一起创业，最起码赚不到钱，还能学到不少。不会有过多的损失。别热血一沸腾就创业了，创业了，也别烧自己的钱，家人的钱，那是很不抗烧的，没几下几十万就烧干了。其实打工，也是创业的开始，每个月都能拿到钱，还可以学到知识，什么公司的股份都是空话，没几个小公司能成功，开起来了也走不了3年就分家了，都忽悠小孩子玩的，除非真的有科技含量或者是客户资源的，否则股份是一文钱不值的，就算创业每个月也按时拿工资才是硬道理。 13. 未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。在未来，我们享受良好的服务的同时，也会为别人提供更良好的服务，需要在技能上还是服务质量上的要求会更高更严格。平时要注意提高自己，不要被时代淘汰掉，我从小的朋友，一波又一波被社会无情的淘汰了，很小的时候，我出生在大草原与大山的交界处，我小时候的玩伴，还在大山里，我跟着家人杀出来了，我小学、中学、大学、工作上的、这10年，我一直很坚强的拼搏下来，很不容易的在杭州立住脚了，说实话，参加工作后的十年，也是不断拼搏，不断提高的十年。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2.1.3Winsock网络编程知识（下）]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-3Winsock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[！上接Winsock网络编程知识（上）！sockaddr结构体是为了保持各个特定协议之间的兼容性而设计的。为bind()函数指定的地址和端口时，向sockaddr_in结构体填充相应的内容，而调用函数时应该使用sockaddr结构体。在sockaddr_in结构体中，还有一个结构体in_addr，该结构体在winsock2.h中的定义如下:1234567struct in_addr&#123; union &#123; struct &#123; u_char s_bl,s_b2,s_b3,s_b4; &#125; S_un_b; struct &#123; u_short s_wl,s_w2; &#125; S_un_w; u_long S_addr; &#125;S_un;&#125;; 该结构体是一个共用体S_un，包含2个结构体变量和1u_long类型变量。一般使用的IP地址的数据类型是使用点分十进制表示的,而in_addr结构体中却没有提供用来保存点分十进制表示IP地址的数据类型，只是需要使用转换函数，把点分十进制表示的IP地址转换成in_addr结构体可以接受的类型。这里使用的转换函数是inet_addr(),该函数的定义如下：1unsigned long inet_addr(const char FAR *cp); 该函数是将点分十进制表示的IP地址转换成unsigned long类型的数值。该函数的参数cp是指向点分十进制IP地址的字符指针。同时该函数也是一个逆函数，是将unsigned long型的数值型IP地址转换成点分十进制的IP地址，该函数的定义如下：1char FAR * inet_ntoa(struct in_addr in); sockaddr_in结构体中的sin_port表示端口，这个端口需要使用大尾方式字节序存储（也称大端和小端，是两种不同的存储方式。）在intel X86架构下，数值存储方式默认W为小尾方式字节序，而TCP/IP的数值的存储方式都是大尾方式的字节序。为了实现方便的转换，winsock2.h中提供为了方便的函数，即htons()和htonl()两个函数，并且提供了他们的逆函数ntohs()和ntohl()。htons()和htonl()函数的定义分别如下：12u_short htons(u_short hostshort);u_long htonl(u_long hostlong); ntohs()和ntohl()函数的定义分别如下：12u_short ntohs(u_short netshort);u_long ntohl(u_long netlong); 这4个函数中，前两个函数是将主机字节序转换成网络字节序，后两个是将网络字节序转换成主机字节序。在有些架构系统下，主机字节序和网络字节序是相同的，那么转换函数不进行任何转换，但是为了代码的移植性，还是会进行转换函数的调用。具体的bind()函数的使用方法如下：12345678910//创建套接字SOCKET sListen = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);//对sockaddr_in结构体填充地址、端口等信息struct sockaddr_in ServerAddr;ServerAddr.sin_family = AF_INET;ServerAddr.sin_addr.S_un.S_addr = inet_addr("10.10.30.16");ServerAddr.sin_port = htons(1234);//绑定套接字与地址信息bind(sLisent, (SOCKADDR *)&amp;ServerAddr, sizeof(serverAddr)); PS:对于服务器的地址可以指定为INADDR_ANY宏，表示“任意地址”或者“所有地址”。当客户端发起连接时。服务器操作系统接收到客户端的连接，根据网络的配置情况会自动选择一个IP地址和客户端进行通信。当套接字与地址端口信息绑定后，就需要让端口进行监听，当端口进行监听状态以后就可以接受其他主机的连接了。监听端口和接受连接请求的函数分别为listen()和accept()。监听端口的函数定义如下：1int listen(SOCKET s, int backlog); 该函数有两个参数，第1个参数s是指定要监听的套接字描述符，第2个参数是backlog是允许进入请求连接队列的个数，backlog的最大值由系统指定，在winsock2.h中，其最大值由SOMAXCONN表示，该值的定义如下：1#define SOMAXCONN 0x7fffffff 接受连接请求的函数定义如下：1SOCKET accept(SOCKET s,struct sockaddr FAR *addr, int FAR *addrlen); 该函数从连接请求队列中获取连接信息，创建新的套接字描述符，获取客户端地址。新创建的套接字用于和客户端进行通信。该函数有3个参数，第1个参数s是处于监听套接字描述符，第2个参数addr是一个指向sockaddr结构体的指针，用来返回客户端的地址信息，第3个参数addrlen是一个指向int型的指针变量，用来传入sockaddr结构体的大小。上面介绍的是面向连接的服务器端的函数，完成了一系列服务器应有的基本动作，如下： 首先，bind()函数将套接字描述符与地址信息进行绑定； 其次，listen()函数将套接字描述符置于监听状态； 最后，accept()函数获取连接队列中的连接信息，创建新的套接字描述符，以便与客户端通信。面向连接的客户端只需要完成与服务器的连接这样一个动作就可以实现和服务器的通信了。创建套接字描述符后，使用connect()函数就可以完成与服务器的连接。connet函数的定义如下：1int connet(SOCKES s, const struct sockaddr FAR *name,int namelen); 该函数的作用是将套接字进行连接。该函数有3个参数，第1个参数表示创建好的套接字描述符，第2个参数name是指向sockaddr结构体的指针，sockaddr结构体中保存了服务器的IP和端口号，第3个参数namelen是指定sockaddr结构体的长度。当客户端使用connect()函数与服务器连接后，客户端和服务器就可以通信了。通信时主要就是信息的发送和接收。这里介绍的函数有两个，分别是send()和recv()。发送函数send()的定义如下：1int recv(SOCKET s, const char FAR *buf, int len, int flags); 该函数有4个参数，第1个参数s是accept()函数返回的套接字描述符，第二个参数buf是发送消息的缓冲区，第3个参数len是缓冲区的长度，第4个参数flags通常赋值为0值。接收函数recv()的定义如下：1int recv(SOCKET s,char FAR *buf,int len, int flags); 该函数有4个参数，该函数的使用方法和send()函数的使用方法相同。这里不再介绍。 4.非面向连接协议的函数在面向连接的TCP协议中，服务器端将套接字描述符与地址进行绑定后，需要将端口进行监听，等待接受客户端的连接请求，而在客户端则需要连接服务器，完成这些步骤就可以保证面向连接的TCP协议的可靠传输，在调用connect()函数的过程中也完成了TCP的“三次握手”的过程。非面向连接的UDP协议在开发上基本与面向连接TCP相同。在非面向连接的UDP协议开发中服务器端不需要对端口进行监听，也就不需要等待接受客户端的连接请求，而客户端也不需要完成与服务器的连接。中间的“三次握手”过程也就省略了，这样UDP协议现对于TCP协议来讲就显得不可靠，但是效率会更高。（游戏方面一般采用DUP协议）在非面向连接协议开发中，服务器端不再调用listen()、accept()函数，客户端不再需要调用connect()函数。而服务器和客户端的通信换为sendto()和recvfrom()函数即可。sendto函数的定义如下：12345678int sendto( SOCKET s, const char FAR *buf, int len, int flags, const struct sockaddr FAR *to, int tolen); 该函数是用来在UDP协议通信双方进行发送数据的函数，该函数有6个参数，第1个参数s是套接字描述符，第2个参数buf是要发送数据的缓冲区，第3个参数len是指定第2个参数的长度，第4个参数通常赋0值，第5个参数to是一个指向sockaddr结构体的指针，这里给出接收信息的地址信息，第6个参数tolen是指定第5个参数的长度。recvfrom()函数的定义如下：12345678int recvfrom( SOCKET s, const char FAR *buf, int len, int flags, const struct sockaddr FAR *from, int FAR *fromlen); 该函数是用来在UDP协议通信双方进行接收数据的函数。该函数的用法与sendto()相同，这里不再介绍。PS：在缓冲区后设置数据的长度是为了防止缓冲区溢出！]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Winsock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3Winsock网络编程知识（上）]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-3Winsock%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.Winsock的初始化与释放在使用winsock相关函数时需要对Winsock库进行初始化，而在使用完后需要对Winsock库进行释放。 Winsock库的初始化函数的定义如下：1int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData); 该函数的第1个参数wVersionRequested是需要初始化的Winsock库的版本号，Winsock库有多个版本号，目前常用的版本是2.2.第二个参数lpWSAData是一个指向WSADATA的指针。该函数的返回值为0，说明该函数调用成功。如果调用失败，则返回其他值。在程序的开始处调用该初始化函数，在程序中就可以使用Winsock相关的所有API函数。 Winsock库的释放函数的定义int WSACleanup(void);该函数没有参数，在程序的结束处直接调用该函数，即可释放Winsock库。 2.套接字的创建与关闭套接字用于根据指定的协议类型来分配一个套接字描述符。该描述符主要用在客户端和服务器端进行通信，当套接字使用完毕时应该关闭套接字以释放资源。创建套接字与关闭套接字的函数为socket()和closesocket()。 创建套接字的函数定义如下：1SOCKET socket(int af,int type, int protocol); socket()函数共有3个参数，第1个参数af用来指定地址族，在Windows下可以使用的参数有很多个，但是真正可以使用的只有两个，分别说AF_INET和PF_INET。这两个宏在Winsock2.h下的定义相同，分别如下：123456#define AF_INET 2 /* internetwork:UDP, TCP, etc. *//** Protocol families,same as address families for now*/#define PF_INET AF_INET 以上两个定义都摘自Winsock2.h头文件。从定义来看，PF_INET和AF_INET是相同的。看PF_INET宏定义上面的注释，AF表示地址族（Address Family）,而PF表示协议族（Protocol Family）。对于Windows来说，两者相同；对于Unix/Linux来说，两者是不同的。一般情况下，调用socket()函数时应使用PF_INET，而在设置地址时使用AF_INET。sock()函数的第2个参数type是指定新套接字描述符的类型。这里可以使用的值通常有3个，分别是SOCK_STREAM、SOCK_DGRAM和SOCK_RAW，分别表示流套接字、数据包套接字和原始协议接口。socket()函数的第3个参数Protocol用来指定程序所使用的通信协议，这里可以选择使用IPPROTO_TCP、IPPROTO_UDP、IPPROTO_ICMP等协议，这个参数的值是根据第2个参数的值进行选择。第2个参数如果使用SOCK_STREAM，那么第3个参数应该使用IPPROTO_TCP；如果第2个参数使用SOCK_DGRAM，那么第3个参数应该使用IPPROTO_UDP。也就是说，如果第2个参数是SOCK_STREAM或SOCK_DGRAM，那么第3个参数可以默认为0.如果第2个参数指定的是SOCK_RAW，那么第3个参数必须指定，而不能使用0值。socket()函数调用成功返回值为一个新的套接字描述符，如果调用失败，则返回INVALID_SOCKET。调用失败后，想要知道原因，那么紧接着调用WSAGetLastError()函数得到错误码。PS：所有的Winsock函数出错后都可以调用WSAGetLastError()得到错误码。 关闭套接字的函数定义如下：1int closesocket(SOCKET s); closesocket()函数是socket()函数创建的套接字描述符。PS：对于WSAStartup()/WSACleanup()和socket()/closesocket()这样的函数，最好保持成对出现。也就是说，在写完一个函数时，立刻写出另外一个函数的调用，以免忘记资源的释放。 3.面向连接协议的函数前面的部分提到了面向连接协议与非面向连接协议所用到的函数是不相同的。这里来介绍面向连接的函数：bind()、listen()、accept()、send()和recv()。这些函数是常用的面向连接的函数，只是一个基础。Winsock库的函数非常多，这里只是寥寥几个而已，下面介绍函数的使用方法。通过socket()函数可以直接创建一个新的套接字描述符，但是它只是一个描述符，为网络的一些资源做准备。要想真正在网络上进行通信，需要本地的地址与本地的端口号信息。当然，本地的地址与端口号信息需要和套接字描述符进行关联，进行绑定。在Winsock函数中，使用bind()函数完成套接字与地址端口信息的绑定。bind()函数的定义如下：1int bind(SOCKET s, const struct sockaddr FAR *name, int namelen); 该函数有3个参数，第1个参数s是新创建的套接字描述符，也就是用socket()函数创建的描述符，第2个参数name是一个sockaddr的结构体，提供套接字一个地址和端口信息，第3个参数namelen是sockaddr结构体的大小。其中第二个参数sockaddr结构体的定义如下：1234struct sockaddr&#123; u_short sa_family； /* address family */ char sa_data[14]; /* up to 14 bytes of direct address */&#125;； 该结构体共有16个字节，在该结构体之前所使用的协议为sockadd_in，该结构体的定义如下:123456struct sockadd_in&#123;short sin_family;u_short sin_port;struct in_add sin_addr;char sin_size[8];&#125;; ！未完待续！]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Winsock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2面向与非面连接协议所使用的函数]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-2%E9%9D%A2%E5%90%91%E4%B8%8E%E9%9D%9E%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.面向连接的协议在面向连接的协议中，两台计算机之间在进行数据收发前，必须先在两者之间建立一个通信通道，以确保两台计算机之间存在一条路径可以相互沟通。在数据传输完毕之后，切断这条通信通道。该种方式相当于打电话。面向连接的协议使用的是TCP协议，服务器与客户端建立通信信道所需要的基本Winsock函数如下： 服务器端函数：socket()-&gt;bind-&gt;listen()-&gt;accept()-&gt;send()/recv()-&gt;closesocket() 客户端函数：socket()-&gt;connet()-&gt;send()/recv()-&gt;closesocket() 2.非面向连接的协议在非面向连接的协议中，发送端只要直接将要发送的数据传出即可，不需要理会接送方是否能够接收到数据。而接受端在接受数据时，也不会响应消息通知发送给发送端。该种方式相当于写信，将写好的信放到信箱中，但是却不能保证收信人真的能够收到这封信。非面向连接使用的是UDP协议，服务器与客户端通信所需要的基本Winsock函数如下： 服务器端函数：socket()-&gt;bind-&gt;sendto()/recvfrom()-&gt;closesocket() 客户端函数：socket()-&gt;sendto()/recvfrom()-&gt;closesocket() linux下的sock函数：socket(domain,int type,int protocol)用于创建一个新的套接字，返回一个表示套接字的文件描述符，错误时返回-1。connect(int fd,struct sockaddr *remove_host,socklen_t addr_length)将一个套接字（有文件描述符fd指定）连接远程主机。成功返回0，错误返回-1。bind(int fd,struct sockaddr *local_addr,socklen_t addr_length)将套接字绑定到一个本地地址，以便它可以侦听传入的连接。成功返回0，错误返回-1。listen(int fd,int backlog_queue_size)侦听传入的连接并将连接请求排队，知道数量达到backlog_queue_size。成功返回0，错误返回-1。accept(int fd,sockaddr *remove_host,socklen_t *addr_length)在一个绑定的端口接受一个传入的连接。远程主机的地址信息写入remote_host结构中，地址结构的实际大小写入到addr_length中。这个函数返回一个新的套接字文件描述符来标识已经连接的套接字，错误返回-1。`send(int fd,void buffer,size_t n,int flags)从*buffer向套接字fd发送n个字节，返回值为发送的字节数，错误返回-1。recv(int fd,void buffer,size_t n, int flags)`从套接字fd接受n个字节到buffer中，返回值为发送的字节数，错误返回-1。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1网络基础知识]]></title>
    <url>%2F2018%2F07%2F01%2F2.1.1%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[各种计算机之间通过互联网进行通信主要依靠TCP/IP协议。该协议分为4层，由上到下分别为应用层、传输层、网际层和链路层。TCP/IP协议总是下层为上层协议服务，下层协议的细节对上层协议来说是透明的。TCP/IP协议在每层协议中都定义了非常多的不同的协议，比如网际层的ICMP协议、IGMP协议，传输层的TCP协议、UDP协议等。在众多协议中，最具有代表性的是TCP/IP协议。 IP协议是“Internet Protocol”的简称，它是计算机网络相互连接进行通信而设计的协议。在IP协议中最重要的就是IP地址，IP地址是用来在网络上唯一标识一台计算机主机的地址。互联网中没有两个机器有相同的IP地址，因此它是用来标识一台网络主机的。所有的IP地址都是32位长，它用点分十进制表示，比如“10.10.30.16”。IP地址指定的不是主机，而是网络接口设备。因此，一台主机有两个网络接口，那么就会有两个IP地址。通常情况下，对于一台普通主机只有一个网络接口设备，也就只有一个IP地址。比如：个人使用的PC通常只有一个IP地址；而对于服务器来说，则会有多个网络接口设备，每个网络接口设备都有一个IP地址，比如WEB服务器可能就会有多个IP地址。 IP地址被分为5类，分别是A类、B类、C类、D类和E类。各类IP地址范围如下所示。 传输层有两大协议，分别是TCP协议和UDP协议。TCP协议是“Transmission Control Protocol”的简称，其意思是传输层控制协议。TCP协议是一种面向连接的、可靠的通信协议。TCP协议是IP协议的上层协议，IP协议服务于TCP协议。UDP协议是“User Datagram Protocol”的简称，其意思为用户包协议。UDP协议是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。传输层是为应用层提供服务的，应用层的协议一部分是基于TCP协议的，比如FTP、HTTP。而一部分是基于UDP的，比如DNS协议。IP层提供了IP地址用来标识网络主机，而传输层提供端口来标识主机中的进程。确定了IP地址和端口号，就确定了网络上的主机以主机上通信的进程。传输层提供了标识通信进程的端口号。按照协议划分，端口号分为TCP端口和UDP端口，TCP端口和UDP端口各有65536个。对于应用程序而言，一般使用大于1024的端口号，因为小于1024的端口属于保留端口。Internet上的很多服务都是用小于1024的端口号。为避免冲突，程序员自己编写的应用程序不要使用小于1024的端口号。同一协议的端口不能冲突，比如Web服务器占用主机TCP协议的80端口，那么另外的程序就不可以再使用TCP协议的80端口。常见的端口号如下图所示。除了小于1024端口号外，还有一些比较有名的端口号，比如MY SQL Server的端口号是1433，Windows的远程桌面端口号是3389等。程序员在编写自己的网络应用程序时，要避免与这些常用端口冲突。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大O记法]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大O记法C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。考虑一个数组，按照数组下标的到一个元素的引用int arr[100];int x = arr[88]; //这个算法就是O(1)的O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例考虑一个list链表list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。O(logN) 算法只花费logN个单位时间长度的时间。logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。O(log(一个亿))约等于19个单位时间的时长。O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。]]></content>
      <tags>
        <tag>算法和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP调试工具]]></title>
    <url>%2F2018%2F06%2F24%2FIP%2F</url>
    <content type="text"><![CDATA[dos下的一些命令netstat -s -p tcp/udp/icmp/ip ping -l 65500 -t 192.168.1.1 #死亡之ping for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.1.%i #批处理ping for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.2.%i nbtstat -a 192.168.1.106 探测主机名 add portopening protocol =all port=135 name=关闭135端口 mode=enable SCOP=Subnet netsh advfirewall firewall add portopening protocol =tcp port=55555 name重要服务 mode=enable delete portopening protocol =tcp port=55555 interface=重要服务 delete portopening TCP 135]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2018%2F06%2F24%2Fvim%2F</url>
    <content type="text"><![CDATA[vim命令行模式，插入模式，末行模式命令模式，不能输入字符移动命令：j 向下移动光标k 向上移动光标h 向左移动光标l 向右移动光标gg 文件顶部G 文件末尾数字gg 移动到数字对应行数字G 移动到数字对应行[ 移动到段落首] 移动到段落尾 Ctrl+b 向上翻页Ctrl+f 向下翻页H 屏幕顶部M 屏幕中间L 屏幕顶部 按i进入插入模式，可输入任意字符按ESC退出插入模式按：进入末行模式 撤销和取消撤销u ctrl+r 删除xn+x （n为数字） 删除N个字符dd 删除光标所在行D 一直删除至行尾dw 删除选中之后直到空格d+数字G 删除选中行到指定行 可视模式按v：可视模式，可选中代码按V：行Ctrl+v：块（可结合移动命令，例如：v+gg） 复制粘贴命令：yy:复制整行代码p:粘贴yy19p 复制19行]]></content>
  </entry>
  <entry>
    <title><![CDATA[memory]]></title>
    <url>%2F2018%2F06%2F24%2Fmemory%2F</url>
    <content type="text"><![CDATA[在C语言中，与其他编译语言一样，编译代码放入text段，而变量驻留在其他段中。究竟是哪个存储器变量取决于变量如何定义。定义在所有函数之外的变量被认为是全局变量。在任何变量前增加关键字static都会使该变量成为静态变量。如果使用数据将静态变量或全局变量初始化了，它们就会存储在data内存段中，否则，这些变量就会存储在bss内存段中。首先，必须使用用户名为malloc()的内存分配函数对对堆内存段中的内存进行分配。通常使用指针来引用堆中的内存。最后，其余的函数变量存储在堆栈内存中。因为堆栈可以包含许多不同的栈帧，所以栈帧变量可以在不同的函数上下文内保持唯一。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int global_var;int global_initialized_var=5;void function()&#123; int stack_var; printf("the function's stack_var is at addres 0x%08x\n",&amp;stack_var);&#125;int main()&#123; int stack_var; static int static_initialized_var=5; static int static_var; int *heap_var_ptr; heap_var_ptr=(int *)malloc(4); printf("global_initialized_var is at addres 0x%08x\n",&amp;global_initialized_var); printf("static_initialized_var is at addres 0x%08x\n\n",&amp;static_initialized_var); printf("static_var is at addres 0x%08x\n",&amp;static_var); printf("global_var is at addres 0x%08x\n\n",&amp;global_var); printf("heap_var is at addres 0x%08x\n\n",heap_var_ptr); printf("static_var is addres 0x%08x\n",&amp;stack_var); function();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程编程基础]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; printf("ThreadProc \r\n"); return 0;&#125;int main()&#123; HANDLE hThread = CreateThread(NULL,0,ThreadProc,NULL,0,NULL); WaitForSingleObject(hThread, INFINITE); printf("main \r\n"); CloseHandle(hThread); return 0;&#125;]]></content>
      <tags>
        <tag>programme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个win32汇编程序]]></title>
    <url>%2F2018%2F06%2F12%2F%E7%AC%AC%E4%B8%80%E4%B8%AAwin32%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Win32编程This is code ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;数据段 .dataszCaption db ‘来自酒猫’,0szText db ‘Hello World’,0szText_OK db ‘您刚点了OK按钮’szCANCEL db ‘您刚点了CANCEL按钮’ ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: invoke MessageBox,NULL,offset szCaption,MB_OKCANCEL or MB_INCONQUESTION cmp eax, IDOK je OK invoke MessageBox,NULL,offset szCANCEL,offset szCaption,MB_OK jmp GOOK: invoke MessageBox,NULL,offset szOK,offset szCaption,MB_OKGO: invoke ExitProcess,NILL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end start12Makefile------- EXE = hello.exe #指定输出文件OBJS = hello.obj #需要的目标文件RES = Fishc.res #需要的资源文件 LINK_FLAG = /subsystem:windows #连接选项ML_FLAG = /c /coff #编译选项 $(EXE): $(OBJS) $(RES) Link $(LINK_FLAG) $(OBJS) $(RES) .asm.obj: ml $(ML_FLAG) $&lt;.rc.res: rc $&lt; clean: del .obj del .res]]></content>
  </entry>
  <entry>
    <title><![CDATA[删除所有分区共享批处理]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[删除所有分区共享 先列举存在的分区，然后再逐个删除以分区命名的共享； 通过修改注册表防止admin$共享在下次开机时重新加载； IPC$共享需要administritor权限才能删除 This is code @echo off title 默认共享删除器 echo. echo ---------------------------------------------- echo. echo 开始删除每个分区下的默认共享 echo. for %%a in (C D E F G H I J K L M N O P Q R S T U V W X Y Z) do @( if exist %%a:\nul ( net share %%a$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 %%a$的默认共享 || echo 名为 %%a$的默认共享不存在 ) ) net share admin$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 admin$的默认共享 || echo 名为 admin$的默认共享不存在 echo. echo ---------------------------------------------- echo. net stop Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已停止 net start Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已启动 echo. echo ---------------------------------------------- echo. echo 修改注册表以更改系统默认设置 echo. echo 正在创建注册表文件 echo Windows Registry Editor Version 5.00&gt; c:\delshare.reg :: 通过修改注册表禁止admin$共享，以防重启后再次加载 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt;c:\delshare.reg echo &quot;AutoShareWks&quot;=dword:00000000&gt;&gt; c:\delshare.reg echo &quot;AutoShareServer&quot;=dword:00000000&gt;&gt; c:\delshare.reg ::删除IPC$共享，本功能需要administrator权限才能成功删除 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa]&gt;&gt; c:delshare.reg echo &quot;restrictanonymous&quot;=dword:00000001&gt;&gt; c:\delshare.reg echo 正在导入注册表以更改系统默认设置 regedit /s c:\delshare.reg del c:\delshare.reg &amp;&amp; echo 临时文件已经删除 echo. echo ---------------------------------------------- echo. echo 程序已经成功删除所有的默认共享 echo. echo 按任意键退出... pause&gt;nul]]></content>
  </entry>
</search>
