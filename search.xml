<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2.1.2面向与非面连接协议所使用的函数]]></title>
    <url>%2F2018%2F07%2F01%2F2-1-2%E9%9D%A2%E5%90%91%E4%B8%8E%E9%9D%9E%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.面向连接的协议在面向连接的协议中，两台计算机之间在进行数据收发前，必须先在两者之间建立一个通信通道，以确保两台计算机之间存在一条路径可以相互沟通。在数据传输完毕之后，切断这条通信通道。该种方式相当于打电话。面向连接的协议使用的是TCP协议，服务器与客户端建立通信信道所需要的基本Winsock函数如下： 服务器端函数：socket()-&gt;bind-&gt;listen()-&gt;accept()-&gt;send()/recv()-&gt;closesocket() 客户端函数：socket()-&gt;connet()-&gt;send()/recv()-&gt;closesocket() 2.非面向连接的协议在非面向连接的协议中，发送端只要直接将要发送的数据传出即可，不需要理会接送方是否能够接收到数据。而接受端在接受数据时，也不会响应消息通知发送给发送端。该种方式相当于写信，将写好的信放到信箱中，但是却不能保证收信人真的能够收到这封信。非面向连接使用的是UDP协议，服务器与客户端通信所需要的基本Winsock函数如下： 服务器端函数：socket()-&gt;bind-&gt;sendto()/recvfrom()-&gt;closesocket() 客户端函数：socket()-&gt;sendto()/recvfrom()-&gt;closesocket()]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F2018%2F07%2F01%2F2.1.1%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[各种计算机之间通过互联网进行通信主要依靠TCP/IP协议。该协议分为4层，由上到下分别为应用层、传输层、网际层和链路层。TCP/IP协议总是下层为上层协议服务，下层协议的细节对上层协议来说是透明的。TCP/IP协议在每层协议中都定义了非常多的不同的协议，比如网际层的ICMP协议、IGMP协议，传输层的TCP协议、UDP协议等。在众多协议中，最具有代表性的是TCP/IP协议。 IP协议是“Internet Protocol”的简称，它是计算机网络相互连接进行通信而设计的协议。在IP协议中最重要的就是IP地址，IP地址是用来在网络上唯一标识一台计算机主机的地址。互联网中没有两个机器有相同的IP地址，因此它是用来标识一台网络主机的。所有的IP地址都是32位长，它用点分十进制表示，比如“10.10.30.16”。IP地址指定的不是主机，而是网络接口设备。因此，一台主机有两个网络接口，那么就会有两个IP地址。通常情况下，对于一台普通主机只有一个网络接口设备，也就只有一个IP地址。比如：个人使用的PC通常只有一个IP地址；而对于服务器来说，则会有多个网络接口设备，每个网络接口设备都有一个IP地址，比如WEB服务器可能就会有多个IP地址。 IP地址被分为5类，分别是A类、B类、C类、D类和E类。各类IP地址范围如下所示。 传输层有两大协议，分别是TCP协议和UDP协议。TCP协议是“Transmission Control Protocol”的简称，其意思是传输层控制协议。TCP协议是一种面向连接的、可靠的通信协议。TCP协议是IP协议的上层协议，IP协议服务于TCP协议。UDP协议是“User Datagram Protocol”的简称，其意思为用户包协议。UDP协议是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。传输层是为应用层提供服务的，应用层的协议一部分是基于TCP协议的，比如FTP、HTTP。而一部分是基于UDP的，比如DNS协议。IP层提供了IP地址用来标识网络主机，而传输层提供端口来标识主机中的进程。确定了IP地址和端口号，就确定了网络上的主机以主机上通信的进程。传输层提供了标识通信进程的端口号。按照协议划分，端口号分为TCP端口和UDP端口，TCP端口和UDP端口各有65536个。对于应用程序而言，一般使用大于1024的端口号，因为小于1024的端口属于保留端口。Internet上的很多服务都是用小于1024的端口号。为避免冲突，程序员自己编写的应用程序不要使用小于1024的端口号。同一协议的端口不能冲突，比如Web服务器占用主机TCP协议的80端口，那么另外的程序就不可以再使用TCP协议的80端口。常见的端口号如下图所示。除了小于1024端口号外，还有一些比较有名的端口号，比如MY SQL Server的端口号是1433，Windows的远程桌面端口号是3389等。程序员在编写自己的网络应用程序时，要避免与这些常用端口冲突。]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大O记法]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大O记法C++的大O记法是算法的时间复杂度表达公式。简单的说大O记法可以告诉你一个算法耗费的时间长度同算法所处理的数据量大小的关系。大O记法只是一个概念性的或定性的记号，不能通过它来真正计算一个算法所耗费的精确时长。O(1) 算法只花费一个单位时间长度的时间。同所处理的数据量大小没有关系（常量时间）。“一个单位时间长度”没有定义为1秒，1天，还是1微妙，完全随意指定。大约同处理一个数据项的时长相同。考虑一个数组，按照数组下标的到一个元素的引用int arr[100];int x = arr[88]; //这个算法就是O(1)的O(1)是最爽的，哪怕有1亿条数据还是1条数据，算法所费时间是常量。O(N) 算法只花费N个单位时间长度的时间。数据量大小同算法所花费时长成正比例考虑一个list链表list.remove( 88 ); //把第88个元素删除。这个算法就是O(N)的O(N)是最不爽的，假设有1亿条数据，算法就要花费1亿个时间单位的时长。O(logN) 算法只花费logN个单位时间长度的时间。logN是取对数，可以简单的理解为取以2为底数，N的对数。例如log65536=16 (因为2^16=65536)对数是把一个天文数字般的整数映射成一个小小的整数的数学工具。考虑一个已排序的数组，用“折半法”查找，算法的时间特性就是O(logN)的。O(log(一个亿))约等于19个单位时间的时长。O(logN)也不一定是以2为底的，也可能是以3为底的，这都无所谓。算法在应用于局部小数据量时，可能因为内存的申请，释放，初始化等原因，观察者发现不符合大O记法表示的特性。但是在长期的运行，经过大数据量的考验后，那些干扰因素逐渐沦为次要因素，观察者可以发现算法的却符合某种自己固有的时间特性。]]></content>
      <tags>
        <tag>算法和数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP调试工具]]></title>
    <url>%2F2018%2F06%2F24%2FIP%2F</url>
    <content type="text"><![CDATA[dos下的一些命令netstat -s -p tcp/udp/icmp/ip ping -l 65500 -t 192.168.1.1 #死亡之ping for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.1.%i #批处理ping for /L %i IN (1,1,254) DO ping -w 2 -n 1 192.168.2.%i nbtstat -a 192.168.1.106 探测主机名 add portopening protocol =all port=135 name=关闭135端口 mode=enable SCOP=Subnet netsh advfirewall firewall add portopening protocol =tcp port=55555 name重要服务 mode=enable delete portopening protocol =tcp port=55555 interface=重要服务 delete portopening TCP 135]]></content>
  </entry>
  <entry>
    <title><![CDATA[memory]]></title>
    <url>%2F2018%2F06%2F24%2Fmemory%2F</url>
    <content type="text"><![CDATA[在C语言中，与其他编译语言一样，编译代码放入text段，而变量驻留在其他段中。究竟是哪个存储器变量取决于变量如何定义。定义在所有函数之外的变量被认为是全局变量。在任何变量前增加关键字static都会使该变量成为静态变量。如果使用数据将静态变量或全局变量初始化了，它们就会存储在data内存段中，否则，这些变量就会存储在bss内存段中。首先，必须使用用户名为malloc()的内存分配函数对对堆内存段中的内存进行分配。通常使用指针来引用堆中的内存。最后，其余的函数变量存储在堆栈内存中。因为堆栈可以包含许多不同的栈帧，所以栈帧变量可以在不同的函数上下文内保持唯一。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int global_var;int global_initialized_var=5;void function()&#123; int stack_var; printf("the function's stack_var is at addres 0x%08x\n",&amp;stack_var);&#125;int main()&#123; int stack_var; static int static_initialized_var=5; static int static_var; int *heap_var_ptr; heap_var_ptr=(int *)malloc(4); printf("global_initialized_var is at addres 0x%08x\n",&amp;global_initialized_var); printf("static_initialized_var is at addres 0x%08x\n\n",&amp;static_initialized_var); printf("static_var is at addres 0x%08x\n",&amp;static_var); printf("global_var is at addres 0x%08x\n\n",&amp;global_var); printf("heap_var is at addres 0x%08x\n\n",heap_var_ptr); printf("static_var is addres 0x%08x\n",&amp;stack_var); function();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2018%2F06%2F24%2Fvim%2F</url>
    <content type="text"><![CDATA[vim命令行模式，插入模式，末行模式命令模式，不能输入字符移动命令：j 向下移动光标k 向上移动光标h 向左移动光标l 向右移动光标gg 文件顶部G 文件末尾数字gg 移动到数字对应行数字G 移动到数字对应行[ 移动到段落首] 移动到段落尾 Ctrl+b 向上翻页Ctrl+f 向下翻页H 屏幕顶部M 屏幕中间L 屏幕顶部 按i进入插入模式，可输入任意字符按ESC退出插入模式按：进入末行模式 撤销和取消撤销u ctrl+r 删除xn+x （n为数字） 删除N个字符dd 删除光标所在行D 一直删除至行尾dw 删除选中之后直到空格d+数字G 删除选中行到指定行 可视模式按v：可视模式，可选中代码按V：行Ctrl+v：块（可结合移动命令，例如：v+gg） 复制粘贴命令：yy:复制整行代码p:粘贴yy19p 复制19行]]></content>
  </entry>
  <entry>
    <title><![CDATA[多线程编程基础]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParam)&#123; printf("ThreadProc \r\n"); return 0;&#125;int main()&#123; HANDLE hThread = CreateThread(NULL,0,ThreadProc,NULL,0,NULL); WaitForSingleObject(hThread, INFINITE); printf("main \r\n"); CloseHandle(hThread); return 0;&#125;]]></content>
      <tags>
        <tag>programme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个win32汇编程序]]></title>
    <url>%2F2018%2F06%2F12%2F%E7%AC%AC%E4%B8%80%E4%B8%AAwin32%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Win32编程This is code ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .386 .model flat,stdcall option casemap:none;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;文件定义;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;include windows.incinclude user32.incincludelib user32.libinclude kernel32.incincludelib kernel32.lib;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;数据段 .dataszCaption db ‘来自酒猫’,0szText db ‘Hello World’,0szText_OK db ‘您刚点了OK按钮’szCANCEL db ‘您刚点了CANCEL按钮’ ;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;;代码段;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; .codestart: invoke MessageBox,NULL,offset szCaption,MB_OKCANCEL or MB_INCONQUESTION cmp eax, IDOK je OK invoke MessageBox,NULL,offset szCANCEL,offset szCaption,MB_OK jmp GOOK: invoke MessageBox,NULL,offset szOK,offset szCaption,MB_OKGO: invoke ExitProcess,NILL;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; end start12Makefile------- EXE = hello.exe #指定输出文件OBJS = hello.obj #需要的目标文件RES = Fishc.res #需要的资源文件 LINK_FLAG = /subsystem:windows #连接选项ML_FLAG = /c /coff #编译选项 $(EXE): $(OBJS) $(RES) Link $(LINK_FLAG) $(OBJS) $(RES) .asm.obj: ml $(ML_FLAG) $&lt;.rc.res: rc $&lt; clean: del .obj del .res]]></content>
  </entry>
  <entry>
    <title><![CDATA[删除所有分区共享批处理]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E5%88%86%E5%8C%BA%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[删除所有分区共享 先列举存在的分区，然后再逐个删除以分区命名的共享； 通过修改注册表防止admin$共享在下次开机时重新加载； IPC$共享需要administritor权限才能删除 This is code @echo off title 默认共享删除器 echo. echo ---------------------------------------------- echo. echo 开始删除每个分区下的默认共享 echo. for %%a in (C D E F G H I J K L M N O P Q R S T U V W X Y Z) do @( if exist %%a:\nul ( net share %%a$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 %%a$的默认共享 || echo 名为 %%a$的默认共享不存在 ) ) net share admin$ /delete&gt;nul 2&gt;nul &amp;&amp; echo 成功删除名为 admin$的默认共享 || echo 名为 admin$的默认共享不存在 echo. echo ---------------------------------------------- echo. net stop Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已停止 net start Server&gt;nul 2&gt;nul &amp;&amp; echo Server服务已启动 echo. echo ---------------------------------------------- echo. echo 修改注册表以更改系统默认设置 echo. echo 正在创建注册表文件 echo Windows Registry Editor Version 5.00&gt; c:\delshare.reg :: 通过修改注册表禁止admin$共享，以防重启后再次加载 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters]&gt;&gt;c:\delshare.reg echo &quot;AutoShareWks&quot;=dword:00000000&gt;&gt; c:\delshare.reg echo &quot;AutoShareServer&quot;=dword:00000000&gt;&gt; c:\delshare.reg ::删除IPC$共享，本功能需要administrator权限才能成功删除 echo [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa]&gt;&gt; c:delshare.reg echo &quot;restrictanonymous&quot;=dword:00000001&gt;&gt; c:\delshare.reg echo 正在导入注册表以更改系统默认设置 regedit /s c:\delshare.reg del c:\delshare.reg &amp;&amp; echo 临时文件已经删除 echo. echo ---------------------------------------------- echo. echo 程序已经成功删除所有的默认共享 echo. echo 按任意键退出... pause&gt;nul]]></content>
  </entry>
</search>
